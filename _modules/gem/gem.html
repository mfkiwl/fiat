<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gem.gem &#8212; FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=2bf1fcf8" />
    
    <script src="../../_static/documentation_options.js?v=e952a2db"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gem.gem</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gem.gem</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;GEM is the intermediate language of TSFC for describing</span>
<span class="sd">tensor-valued mathematical expressions and tensor operations.</span>
<span class="sd">It is similar to Einstein&#39;s notation.</span>

<span class="sd">Its design was heavily inspired by UFL, with some major differences:</span>
<span class="sd"> - GEM has got nothing FEM-specific.</span>
<span class="sd"> - In UFL free indices are just unrolled shape, thus UFL is very</span>
<span class="sd">   restrictive about operations on expressions with different sets of</span>
<span class="sd">   free indices. GEM is much more relaxed about free indices.</span>

<span class="sd">Similarly to UFL, all GEM nodes have &#39;shape&#39; and &#39;free_indices&#39;</span>
<span class="sd">attributes / properties. Unlike UFL, however, index extents live on</span>
<span class="sd">the Index objects in GEM, not on all the nodes that have those free</span>
<span class="sd">indices.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Number</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">asarray</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">gem.node</span><span class="w"> </span><span class="kn">import</span> <span class="n">Node</span> <span class="k">as</span> <span class="n">NodeBase</span><span class="p">,</span> <span class="n">traversal</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">FIAT.orientation_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">Orientation</span> <span class="k">as</span> <span class="n">FIATOrientation</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">,</span> <span class="s1">&#39;Identity&#39;</span><span class="p">,</span> <span class="s1">&#39;Literal&#39;</span><span class="p">,</span> <span class="s1">&#39;Zero&#39;</span><span class="p">,</span> <span class="s1">&#39;Failure&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Variable&#39;</span><span class="p">,</span> <span class="s1">&#39;Sum&#39;</span><span class="p">,</span> <span class="s1">&#39;Product&#39;</span><span class="p">,</span> <span class="s1">&#39;Division&#39;</span><span class="p">,</span> <span class="s1">&#39;FloorDiv&#39;</span><span class="p">,</span> <span class="s1">&#39;Remainder&#39;</span><span class="p">,</span> <span class="s1">&#39;Power&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MathFunction&#39;</span><span class="p">,</span> <span class="s1">&#39;MinValue&#39;</span><span class="p">,</span> <span class="s1">&#39;MaxValue&#39;</span><span class="p">,</span> <span class="s1">&#39;Comparison&#39;</span><span class="p">,</span>
           <span class="s1">&#39;LogicalNot&#39;</span><span class="p">,</span> <span class="s1">&#39;LogicalAnd&#39;</span><span class="p">,</span> <span class="s1">&#39;LogicalOr&#39;</span><span class="p">,</span> <span class="s1">&#39;Conditional&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Index&#39;</span><span class="p">,</span> <span class="s1">&#39;VariableIndex&#39;</span><span class="p">,</span> <span class="s1">&#39;Indexed&#39;</span><span class="p">,</span> <span class="s1">&#39;ComponentTensor&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndexSum&#39;</span><span class="p">,</span> <span class="s1">&#39;ListTensor&#39;</span><span class="p">,</span> <span class="s1">&#39;Concatenate&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta&#39;</span><span class="p">,</span> <span class="s1">&#39;OrientationVariableIndex&#39;</span><span class="p">,</span>
           <span class="s1">&#39;index_sum&#39;</span><span class="p">,</span> <span class="s1">&#39;partial_indexed&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;view&#39;</span><span class="p">,</span>
           <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="s1">&#39;as_gem&#39;</span><span class="p">,</span> <span class="s1">&#39;FlexiblyIndexed&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Inverse&#39;</span><span class="p">,</span> <span class="s1">&#39;Solve&#39;</span><span class="p">,</span> <span class="s1">&#39;extract_type&#39;</span><span class="p">,</span> <span class="s1">&#39;uint_type&#39;</span><span class="p">]</span>


<span class="n">uint_type</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">uintc</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NodeMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Metaclass of GEM nodes.</span>

<span class="sd">    When a GEM node is constructed, this metaclass automatically</span>
<span class="sd">    collects its free indices if &#39;free_indices&#39; has not been set yet.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Create and initialise object</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NodeMeta</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Set free_indices if not set already</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;free_indices&#39;</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">free_indices</span>
                                              <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">children</span><span class="p">]))</span>
        <span class="c1"># Set dtype if not set already.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>


<div class="viewcode-block" id="Node">
<a class="viewcode-back" href="../../gem.html#gem.gem.Node">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">(</span><span class="n">NodeBase</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">NodeMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract GEM node class.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;free_indices&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Node.is_equal">
<a class="viewcode-back" href="../../gem.html#gem.gem.Node.is_equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Common subexpression eliminating equality predicate.</span>

<span class="sd">        When two (sub)expressions are equal, the children of one</span>
<span class="sd">        object are reassigned to the children of the other, so some</span>
<span class="sd">        duplicated subexpressions are eliminated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">NodeBase</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">componentwise</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">componentwise</span><span class="p">(</span>
            <span class="n">Sum</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span>
            <span class="n">componentwise</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="n">Literal</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">componentwise</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both objects must have shape for matmul&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mismatching shapes </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> in matmul&quot;</span><span class="p">)</span>
        <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">_</span><span class="p">,</span> <span class="o">*</span><span class="n">j</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">Indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">)),</span>
                       <span class="n">Indexed</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">IndexSum</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">)),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">Indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator must be scalar&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">componentwise</span><span class="p">(</span><span class="n">Division</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator must be scalar&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">componentwise</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator must be scalar&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">componentwise</span><span class="p">(</span><span class="n">Remainder</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Node.inherit_dtype_from_children">
<a class="viewcode-back" href="../../gem.html#gem.gem.Node.inherit_dtype_from_children">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inherit_dtype_from_children</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">):</span>
            <span class="c1"># Set dtype = None will let _assign_dtype()</span>
            <span class="c1"># assign the default dtype for this node later.</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">))</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">Terminal</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class for terminal GEM nodes.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_dtype&#39;</span><span class="p">,)</span>

    <span class="n">children</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">is_equal</span> <span class="o">=</span> <span class="n">NodeBase</span><span class="o">.</span><span class="n">is_equal</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Data type of the node.</span>

<span class="sd">        We only need to set dtype (or _dtype) on terminal nodes, and</span>
<span class="sd">        other nodes inherit dtype from their children.</span>

<span class="sd">        Currently dtype is significant only for nodes under index DAGs</span>
<span class="sd">        (DAGs underneath `VariableIndex`s representing indices), and</span>
<span class="sd">        `VariableIndex` checks if the dtype of the node that it wraps is</span>
<span class="sd">        of uint_type. _assign_dtype() will then assign uint_type to those nodes.</span>

<span class="sd">        dtype can be `None` otherwise, and _assign_dtype() will assign</span>
<span class="sd">        the default dtype to those nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_dtype&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Must set _dtype on terminal node, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Scalar</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class for scalar-valued GEM nodes.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>


<div class="viewcode-block" id="Failure">
<a class="viewcode-back" href="../../gem.html#gem.gem.Failure">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Failure</span><span class="p">(</span><span class="n">Terminal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class for failure GEM nodes.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;exception&#39;</span><span class="p">)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;exception&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">exception</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception</span> <span class="o">=</span> <span class="n">exception</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="kc">None</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">Constant</span><span class="p">(</span><span class="n">Terminal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for constant types.</span>

<span class="sd">    Convention:</span>
<span class="sd">     - array: numpy array of values</span>
<span class="sd">     - value: float or complex value (scalars only)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="Zero">
<a class="viewcode-back" href="../../gem.html#gem.gem.Zero">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Zero</span><span class="p">(</span><span class="n">Constant</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Symbolic zero tensor&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">or</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>



<div class="viewcode-block" id="Identity">
<a class="viewcode-back" href="../../gem.html#gem.gem.Identity">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Identity</span><span class="p">(</span><span class="n">Constant</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identity matrix&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dim&#39;</span><span class="p">,)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dim&#39;</span><span class="p">,)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>



<div class="viewcode-block" id="Literal">
<a class="viewcode-back" href="../../gem.html#gem.gem.Literal">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Literal</span><span class="p">(</span><span class="n">Constant</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tensor-valued constant&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">,)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">,)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assume float or complex.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Can be int, etc.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span>

<div class="viewcode-block" id="Literal.is_equal">
<a class="viewcode-back" href="../../gem.html#gem.gem.Literal.is_equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span></div>


<div class="viewcode-block" id="Literal.get_hash">
<a class="viewcode-back" href="../../gem.html#gem.gem.Literal.get_hash">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">)))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span></div>



<div class="viewcode-block" id="Variable">
<a class="viewcode-back" href="../../gem.html#gem.gem.Variable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Variable</span><span class="p">(</span><span class="n">Terminal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Symbolic variable tensor&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span></div>



<div class="viewcode-block" id="Sum">
<a class="viewcode-back" href="../../gem.html#gem.gem.Sum">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Sum</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]))</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Product">
<a class="viewcode-back" href="../../gem.html#gem.gem.Product">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Product</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]))</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Division">
<a class="viewcode-back" href="../../gem.html#gem.gem.Division">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Division</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;division by zero&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]))</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Division</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="FloorDiv">
<a class="viewcode-back" href="../../gem.html#gem.gem.FloorDiv">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FloorDiv</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">uint_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dtype (</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">) != unit_type (</span><span class="si">{</span><span class="n">uint_type</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;division by zero&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">//</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FloorDiv</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Remainder">
<a class="viewcode-back" href="../../gem.html#gem.gem.Remainder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Remainder</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">uint_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dtype (</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">) != uint_type (</span><span class="si">{</span><span class="n">uint_type</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;division by zero&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Remainder</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Power">
<a class="viewcode-back" href="../../gem.html#gem.gem.Power">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Power</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">base</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">exponent</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="p">])</span>

        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot solve 0^0&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">value</span> <span class="o">**</span> <span class="n">exponent</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Power</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">base</span><span class="p">,</span> <span class="n">exponent</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="MathFunction">
<a class="viewcode-back" href="../../gem.html#gem.gem.MathFunction">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MathFunction</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;children&#39;</span><span class="p">)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;conj&#39;</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">}:</span>
            <span class="n">arg</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arg</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MathFunction</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="MinValue">
<a class="viewcode-back" href="../../gem.html#gem.gem.MinValue">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MinValue</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="MaxValue">
<a class="viewcode-back" href="../../gem.html#gem.gem.MaxValue">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaxValue</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="Comparison">
<a class="viewcode-back" href="../../gem.html#gem.gem.Comparison">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Comparison</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;operator&#39;</span><span class="p">,</span> <span class="s1">&#39;children&#39;</span><span class="p">)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;operator&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="s2">&quot;!=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid operator&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Do not inherit dtype from children.</span></div>



<div class="viewcode-block" id="LogicalNot">
<a class="viewcode-back" href="../../gem.html#gem.gem.LogicalNot">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogicalNot</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">expression</span><span class="p">,</span></div>



<div class="viewcode-block" id="LogicalAnd">
<a class="viewcode-back" href="../../gem.html#gem.gem.LogicalAnd">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogicalAnd</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="LogicalOr">
<a class="viewcode-back" href="../../gem.html#gem.gem.LogicalOr">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LogicalOr</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="Conditional">
<a class="viewcode-back" href="../../gem.html#gem.gem.Conditional">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Conditional</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">then</span><span class="p">,</span> <span class="n">else_</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">condition</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">then</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">else_</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span>

        <span class="c1"># If both branches are the same, just return one of them.  In</span>
        <span class="c1"># particular, this will help constant-fold zeros.</span>
        <span class="k">if</span> <span class="n">then</span> <span class="o">==</span> <span class="n">else_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">then</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Conditional</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">condition</span><span class="p">,</span> <span class="n">then</span><span class="p">,</span> <span class="n">else_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">then</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">([</span><span class="n">then</span><span class="p">,</span> <span class="n">else_</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">IndexBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for indices.&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="n">IndexBase</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


<div class="viewcode-block" id="Index">
<a class="viewcode-back" href="../../gem.html#gem.gem.Index">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Index</span><span class="p">(</span><span class="n">IndexBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Free index&quot;&quot;&quot;</span>

    <span class="c1"># Not true object count, just for naming purposes</span>
    <span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">Index</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">Index</span><span class="o">.</span><span class="n">_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">extent</span>

<div class="viewcode-block" id="Index.set_extent">
<a class="viewcode-back" href="../../gem.html#gem.gem.Index.set_extent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Set extent, check for consistency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistent index extents!&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;i_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Index(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">return</span> <span class="s2">&quot;Index(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Allow sorting of free indices in Python 3</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">state</span></div>



<div class="viewcode-block" id="VariableIndex">
<a class="viewcode-back" href="../../gem.html#gem.gem.VariableIndex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VariableIndex</span><span class="p">(</span><span class="n">IndexBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An index that is constant during a single execution of the</span>
<span class="sd">    kernel, but whose value is not known at compile time.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;expression&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">expression</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">uint_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expression.dtype (</span><span class="si">{</span><span class="n">expression</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">) != uint_type (</span><span class="si">{</span><span class="n">uint_type</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">expression</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%r</span><span class="s2">(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,)</span></div>



<div class="viewcode-block" id="Indexed">
<a class="viewcode-back" href="../../gem.html#gem.gem.Indexed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Indexed</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;multiindex&#39;</span><span class="p">,</span> <span class="s1">&#39;indirect_children&#39;</span><span class="p">)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;multiindex&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">):</span>
        <span class="c1"># Accept numpy or any integer, but cast to int.</span>
        <span class="n">multiindex</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">else</span> <span class="n">i</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multiindex</span><span class="p">)</span>

        <span class="c1"># Set index extents from shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggregate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiindex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">extent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multiindex</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">IndexBase</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">index</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">extent</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Invalid literal index&quot;</span><span class="p">)</span>

        <span class="c1"># Empty multiindex</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiindex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">aggregate</span>

        <span class="c1"># Zero folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregate</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">aggregate</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># All indices fixed</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multiindex</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregate</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">aggregate</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">multiindex</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">aggregate</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggregate</span><span class="p">,</span> <span class="n">ListTensor</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">multiindex</span><span class="p">]</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Indexed</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">aggregate</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span> <span class="o">=</span> <span class="n">multiindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indirect_children</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">expression</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">))</span>

        <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multiindex</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                <span class="n">new_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">aggregate</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_indices</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Indexed.index_ordering">
<a class="viewcode-back" href="../../gem.html#gem.gem.Indexed.index_ordering">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">index_ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Running indices in the order of indexing in this node.&quot;&quot;&quot;</span>
        <span class="n">free_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">free_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">free_indices</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FlexiblyIndexed">
<a class="viewcode-back" href="../../gem.html#gem.gem.FlexiblyIndexed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FlexiblyIndexed</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flexible indexing of :py:class:`Variable`s to implement views and</span>
<span class="sd">    reshapes (splitting dimensions only).&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;dim2idxs&#39;</span><span class="p">,</span> <span class="s1">&#39;indirect_children&#39;</span><span class="p">)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dim2idxs&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">dim2idxs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a flexibly indexed node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable : Node</span>
<span class="sd">            `Node` that has a shape.</span>
<span class="sd">        dim2idxs : tuple</span>
<span class="sd">            Tuple of (offset, ((index, stride), (...), ...)) mapping indices,</span>
<span class="sd">            where offset is {Node, int}, index is {Index, VariableIndex, int}, and</span>
<span class="sd">            stride is {Node, int}.</span>

<span class="sd">        For example, if ``variable`` is rank two, and ``dim2idxs`` is</span>

<span class="sd">            ((1, ((i, 12), (j, 4), (k, 1))), (0, ()))</span>

<span class="sd">        then this corresponds to the indexing:</span>

<span class="sd">            variable[1 + i*12 + j*4 + k][0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">variable</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim2idxs</span><span class="p">)</span>
        <span class="n">dim2idxs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">free_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dim2idxs</span><span class="p">):</span>
            <span class="n">offset_</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">idxs_</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">index</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="n">free_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">stride</span><span class="p">))</span>
                    <span class="n">last</span> <span class="o">+=</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">extent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stride</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                    <span class="n">base_indices</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span>
                    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">base_index</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">base_index</span> <span class="ow">in</span> <span class="n">base_indices</span><span class="p">)</span>
                    <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">base_indices</span><span class="p">)</span>
                    <span class="n">idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">stride</span><span class="p">))</span>
                    <span class="c1"># last += (unknown_extent - 1) * stride</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="c1"># TODO: Attach dtype to each Node.</span>
                    <span class="c1"># Here, we should simply be able to do:</span>
                    <span class="c1"># &gt;&gt;&gt; offset_ += index * stride</span>
                    <span class="c1"># but &quot;+&quot; and &quot;*&quot; are not currently correctly overloaded</span>
                    <span class="c1"># for indices (integers); they assume floats.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found non-Integral offset : </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
                        <span class="n">offset_</span> <span class="o">+=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">stride</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">offset_</span> <span class="o">+=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">stride</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected index type for flexible indexing&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                    <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">stride</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset_</span> <span class="o">+</span> <span class="n">last</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">offset_</span> <span class="o">+</span> <span class="n">last</span> <span class="o">&gt;=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Offset </span><span class="si">{0}</span><span class="s2"> and indices </span><span class="si">{1}</span><span class="s2"> exceed dimension </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
            <span class="n">dim2idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">offset_</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idxs_</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">variable</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim2idxs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim2idxs_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">free_indices</span><span class="p">)</span>
        <span class="n">indirect_children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim2idxs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                <span class="n">indirect_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                    <span class="n">indirect_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">expression</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                    <span class="n">indirect_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indirect_children</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indirect_children</span><span class="p">)</span>

<div class="viewcode-block" id="FlexiblyIndexed.index_ordering">
<a class="viewcode-back" href="../../gem.html#gem.gem.FlexiblyIndexed.index_ordering">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">index_ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Running indices in the order of indexing in this node.&quot;&quot;&quot;</span>
        <span class="n">free_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim2idxs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">stride</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="n">free_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                    <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                    <span class="n">free_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">stride</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">free_indices</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ComponentTensor">
<a class="viewcode-back" href="../../gem.html#gem.gem.ComponentTensor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ComponentTensor</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;multiindex&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;multiindex&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Empty multiindex</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiindex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span>

        <span class="c1"># Collect shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">multiindex</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Zero folding</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">expression</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ComponentTensor</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">expression</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span> <span class="o">=</span> <span class="n">multiindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="c1"># Collect free indices</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">multiindex</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">multiindex</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="IndexSum">
<a class="viewcode-back" href="../../gem.html#gem.gem.IndexSum">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IndexSum</span><span class="p">(</span><span class="n">Scalar</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;multiindex&#39;</span><span class="p">)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;multiindex&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">summand</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">):</span>
        <span class="c1"># Sum zeros</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">summand</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">summand</span>

        <span class="c1"># Unroll singleton sums</span>
        <span class="n">unroll</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">multiindex</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">extent</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unroll</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">index</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">unroll</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">summand</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">ComponentTensor</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="n">unroll</span><span class="p">),</span>
                              <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">unroll</span><span class="p">))</span>
            <span class="n">multiindex</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">multiindex</span>
                               <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unroll</span><span class="p">)</span>

        <span class="c1"># No indices case</span>
        <span class="n">multiindex</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">multiindex</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">multiindex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">summand</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndexSum</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">summand</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiindex</span> <span class="o">=</span> <span class="n">multiindex</span>

        <span class="c1"># Collect shape and free indices</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">multiindex</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">summand</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">summand</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">multiindex</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="ListTensor">
<a class="viewcode-back" href="../../gem.html#gem.gem.ListTensor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ListTensor</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span>

        <span class="c1"># Handle children with shape</span>
        <span class="n">child_shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">child_shape</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">child_shape</span><span class="p">:</span>
            <span class="c1"># Destroy structure</span>
            <span class="n">direct_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">child_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">child_shape</span><span class="p">):</span>
                    <span class="n">direct_array</span><span class="p">[</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">]</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">alpha</span><span class="p">],</span> <span class="n">beta</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">direct_array</span>

        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">))(</span><span class="n">array</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ListTensor</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,)</span>

<div class="viewcode-block" id="ListTensor.reconstruct">
<a class="viewcode-back" href="../../gem.html#gem.gem.ListTensor.reconstruct">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ListTensor</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ListTensor(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<div class="viewcode-block" id="ListTensor.is_equal">
<a class="viewcode-back" href="../../gem.html#gem.gem.ListTensor.is_equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Common subexpression eliminating equality predicate.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="ListTensor.get_hash">
<a class="viewcode-back" href="../../gem.html#gem.gem.ListTensor.get_hash">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="Concatenate">
<a class="viewcode-back" href="../../gem.html#gem.gem.Concatenate">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Concatenate</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flattens and concatenates GEM expressions by shape.</span>

<span class="sd">    Similar to what UFL MixedElement does to value shape.  For</span>
<span class="sd">    example, if children have shapes (2, 2), (), and (3,) then the</span>
<span class="sd">    concatenated expression has shape (8,).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">inherit_dtype_from_children</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">((</span><span class="n">size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Concatenate</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)),)</span></div>



<div class="viewcode-block" id="Delta">
<a class="viewcode-back" href="../../gem.html#gem.gem.Delta">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Delta</span><span class="p">(</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Terminal</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">__front__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">)</span>
    <span class="n">__back__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">IndexBase</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">IndexBase</span><span class="p">)</span>

        <span class="c1"># \delta_{i,i} = 1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one</span>

        <span class="c1"># Fixed indices</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">one</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="n">Zero</span><span class="p">()</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">j</span>
        <span class="c1"># Set up free indices</span>
        <span class="n">free_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">free_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Can not make Delta with VariableIndex&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">free_indices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Inverse">
<a class="viewcode-back" href="../../gem.html#gem.gem.Inverse">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Inverse</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The inverse of a square matrix.&quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tensor</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Invert 1x1 matrix</span>
        <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">multiindex</span> <span class="o">=</span> <span class="p">(</span><span class="n">Index</span><span class="p">(),</span> <span class="n">Index</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">Division</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">)),</span> <span class="n">multiindex</span><span class="p">)</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Inverse</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">tensor</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Solve">
<a class="viewcode-back" href="../../gem.html#gem.gem.Solve">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Solve</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solution of a square matrix equation with (potentially) multiple right hand sides.</span>

<span class="sd">    Represents the X obtained by solving AX = B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;children&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="c1"># Shape requirements</span>
        <span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span></div>



<div class="viewcode-block" id="OrientationVariableIndex">
<a class="viewcode-back" href="../../gem.html#gem.gem.OrientationVariableIndex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OrientationVariableIndex</span><span class="p">(</span><span class="n">VariableIndex</span><span class="p">,</span> <span class="n">FIATOrientation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;VariableIndex representing a fiat orientation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the current implementation, we need to extract</span>
<span class="sd">    `VariableIndex.expression` as index arithmetic</span>
<span class="sd">    is not supported (indices are not `Node`).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">expression</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">FloorDiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">expression</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">FloorDiv</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">expression</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">Remainder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">expression</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">as_gem_uint</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">Remainder</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">))</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">unique</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sorts free indices and eliminates duplicates.</span>

<span class="sd">    :arg indices: iterable of indices</span>
<span class="sd">    :returns: sorted tuple of unique free indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">id</span><span class="p">))</span>


<div class="viewcode-block" id="index_sum">
<a class="viewcode-back" href="../../gem.html#gem.gem.index_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">index_sum</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Eliminates indices from the free indices of an expression by</span>
<span class="sd">    summing over them.  Skips any index that is not a free index of</span>
<span class="sd">    the expression.&quot;&quot;&quot;</span>
    <span class="n">multiindex</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span>
                       <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">IndexSum</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">)</span></div>



<div class="viewcode-block" id="partial_indexed">
<a class="viewcode-back" href="../../gem.html#gem.gem.partial_indexed">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">partial_indexed</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generalised indexing into a tensor by eating shape off the front.</span>
<span class="sd">    The number of indices may be less than or equal to the rank of the tensor,</span>
<span class="sd">    so the result may have a non-empty shape.</span>

<span class="sd">    :arg tensor: tensor-valued GEM expression</span>
<span class="sd">    :arg indices: indices, at most as many as the rank of the tensor</span>
<span class="sd">    :returns: a potentially tensor-valued expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tensor</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">shape_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Index</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span>
            <span class="n">Indexed</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">indices</span> <span class="o">+</span> <span class="n">shape_indices</span><span class="p">),</span>
            <span class="n">shape_indices</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;More indices than rank!&quot;</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">strides_of</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate cumulative strides from per-dimension capacities.</span>

<span class="sd">    For example:</span>

<span class="sd">        [2, 3, 4] ==&gt; [12, 4, 1]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])))</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">decompose_variable_view</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract information from a shaped node.</span>
<span class="sd">       Decompose ComponentTensor + FlexiblyIndexed.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">Inverse</span><span class="p">,</span> <span class="n">Solve</span><span class="p">))):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span> <span class="k">for</span> <span class="n">extent</span> <span class="ow">in</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">dim2idxs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">),))</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">)</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FlexiblyIndexed</span><span class="p">)):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">multiindex</span>
        <span class="n">dim2idxs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">),))</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FlexiblyIndexed</span><span class="p">):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">multiindex</span>
        <span class="n">dim2idxs</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dim2idxs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle </span><span class="si">{}</span><span class="s2"> objects.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">variable</span><span class="p">,</span> <span class="n">dim2idxs</span><span class="p">,</span> <span class="n">indexes</span>


<div class="viewcode-block" id="reshape">
<a class="viewcode-back" href="../../gem.html#gem.gem.reshape">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reshape</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reshape a variable (splitting indices only).</span>

<span class="sd">    :arg expression: view of a :py:class:`Variable`</span>
<span class="sd">    :arg shapes: one shape tuple for each dimension of the variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable</span><span class="p">,</span> <span class="n">dim2idxs</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">decompose_variable_view</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
    <span class="n">shape_of</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">shapes</span><span class="p">))</span>

    <span class="n">dim2idxs_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">dim2idxs</span><span class="p">:</span>
        <span class="n">idxs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">extent</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape_of</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape </span><span class="si">{}</span><span class="s2"> does not match extent </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
            <span class="n">strides</span> <span class="o">=</span> <span class="n">strides_of</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">extent</span><span class="p">,</span> <span class="n">stride_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
                <span class="n">index_</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
                <span class="n">idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">index_</span><span class="p">,</span> <span class="n">stride_</span> <span class="o">*</span> <span class="n">stride</span><span class="p">))</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">indexes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_</span><span class="p">)</span>
        <span class="n">dim2idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">offset</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idxs_</span><span class="p">)))</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">FlexiblyIndexed</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim2idxs_</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span></div>



<div class="viewcode-block" id="view">
<a class="viewcode-back" href="../../gem.html#gem.gem.view">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">view</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="o">*</span><span class="n">slices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;View a part of a shaped object.</span>

<span class="sd">    :arg expression: a node that has a shape</span>
<span class="sd">    :arg slices: one slice object for each dimension of the expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variable</span><span class="p">,</span> <span class="n">dim2idxs</span><span class="p">,</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">decompose_variable_view</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
    <span class="n">slice_of</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">slices</span><span class="p">))</span>

    <span class="n">dim2idxs_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">dim2idxs</span><span class="p">:</span>
        <span class="n">offset_</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">idxs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">extent</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">slice_of</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="ow">or</span> <span class="n">dim</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown extent!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Slice exceeds dimension extent!&quot;</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="n">offset_</span> <span class="o">+=</span> <span class="n">start</span> <span class="o">*</span> <span class="n">stride</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span>
            <span class="n">index_</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">indexes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">index_</span>
            <span class="n">idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">index_</span><span class="p">,</span> <span class="n">step</span> <span class="o">*</span> <span class="n">stride</span><span class="p">))</span>
        <span class="n">dim2idxs_</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">offset_</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idxs_</span><span class="p">)))</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">FlexiblyIndexed</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim2idxs_</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span></div>



<span class="c1"># Static one object for quicker constant folding</span>
<span class="n">one</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># Syntax sugar</span>
<div class="viewcode-block" id="indices">
<a class="viewcode-back" href="../../gem.html#gem.gem.indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">indices</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make some :class:`Index` objects.</span>

<span class="sd">    :arg n: The number of indices to make.</span>
<span class="sd">    :returns: A tuple of `n` :class:`Index` objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Index</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">componentwise</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">exprs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply gem op to exprs component-wise and wrap up in a ComponentTensor.</span>

<span class="sd">    :arg op: function that returns a gem Node.</span>
<span class="sd">    :arg exprs: expressions to apply op to.</span>
<span class="sd">    :raises ValueError: if the expressions have mismatching shapes.</span>
<span class="sd">    :returns: New gem Node constructed from op.</span>

<span class="sd">    Each expression must either have the same shape, or else be</span>
<span class="sd">    scalar. Shaped expressions are indexed, the op is applied to the</span>
<span class="sd">    scalar expressions and the result is wrapped up in a ComponentTensor.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span> <span class="o">-</span> <span class="p">{()})</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expressions must have matching shape (or else be scalar)&quot;</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Indexed</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">exprs</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>


<div class="viewcode-block" id="as_gem">
<a class="viewcode-back" href="../../gem.html#gem.gem.as_gem">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">as_gem</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempt to convert an expression into GEM of scalar type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr : Node or Number</span>
<span class="sd">        The expression.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Node</span>
<span class="sd">        A GEM representation of the expression.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If conversion was not possible.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Do not know how to convert </span><span class="si">%r</span><span class="s2"> to GEM&quot;</span> <span class="o">%</span> <span class="n">expr</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">as_gem_uint</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Attempt to convert an expression into GEM of uint type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr : Node or Integral</span>
<span class="sd">        The expression.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Node</span>
<span class="sd">        A GEM representation of the expression.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If conversion was not possible.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint_type</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Do not know how to convert </span><span class="si">%r</span><span class="s2"> to GEM&quot;</span> <span class="o">%</span> <span class="n">expr</span><span class="p">)</span>


<div class="viewcode-block" id="extract_type">
<a class="viewcode-back" href="../../gem.html#gem.gem.extract_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_type</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">klass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collects objects of type klass in expressions.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">traversal</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gem.gem</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, FEniCS Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>