<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>gem.optimise &#8212; FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=2bf1fcf8" />
    
    <script src="../../_static/documentation_options.js?v=e952a2db"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gem.optimise</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gem.optimise</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A set of routines implementing various transformations on GEM</span>
<span class="sd">expressions.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">singledispatch</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">zip_longest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">gem.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">groupby</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gem.node</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">Memoizer</span><span class="p">,</span> <span class="n">MemoizerArg</span><span class="p">,</span> <span class="n">reuse_if_untouched</span><span class="p">,</span>
                      <span class="n">reuse_if_untouched_arg</span><span class="p">,</span> <span class="n">traversal</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gem.gem</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">Failure</span><span class="p">,</span> <span class="n">Identity</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Zero</span><span class="p">,</span>
                     <span class="n">Product</span><span class="p">,</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Comparison</span><span class="p">,</span> <span class="n">Conditional</span><span class="p">,</span> <span class="n">Division</span><span class="p">,</span>
                     <span class="n">Index</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">FlexiblyIndexed</span><span class="p">,</span>
                     <span class="n">IndexSum</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">,</span> <span class="n">ListTensor</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span>
                     <span class="n">partial_indexed</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span>


<div class="viewcode-block" id="literal_rounding">
<a class="viewcode-back" href="../../gem.html#gem.optimise.literal_rounding">[docs]</a>
<span class="nd">@singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">literal_rounding</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform FFC rounding of FIAT tabulation matrices on the literals of</span>
<span class="sd">    a GEM expression.</span>

<span class="sd">    :arg node: root of the expression</span>
<span class="sd">    :arg self: function for recursive calls</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;cannot handle type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>



<span class="n">literal_rounding</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span><span class="p">)(</span><span class="n">reuse_if_untouched</span><span class="p">)</span>


<div class="viewcode-block" id="literal_rounding_literal">
<a class="viewcode-back" href="../../gem.html#gem.optimise.literal_rounding_literal">[docs]</a>
<span class="nd">@literal_rounding</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Literal</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">literal_rounding_literal</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">array</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span>
    <span class="c1"># Mimic the rounding applied at COFFEE formatting, which in turn</span>
    <span class="c1"># mimics FFC formatting.</span>
    <span class="n">one_decimal</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">one_decimal</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">one_decimal</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># no minus zeros</span>
    <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">table</span> <span class="o">-</span> <span class="n">one_decimal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">one_decimal</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span></div>



<div class="viewcode-block" id="ffc_rounding">
<a class="viewcode-back" href="../../gem.html#gem.optimise.ffc_rounding">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ffc_rounding</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform FFC rounding of FIAT tabulation matrices on the literals of</span>
<span class="sd">    a GEM expression.</span>

<span class="sd">    :arg expression: GEM expression</span>
<span class="sd">    :arg epsilon: tolerance limit for rounding</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">Memoizer</span><span class="p">(</span><span class="n">literal_rounding</span><span class="p">)</span>
    <span class="n">mapper</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span>
    <span class="k">return</span> <span class="n">mapper</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span></div>



<span class="nd">@singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_replace_division</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace division with multiplication</span>

<span class="sd">    :param node: root of expression</span>
<span class="sd">    :param self: function for recursive calls</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;cannot handle type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>


<span class="n">_replace_division</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span><span class="p">)(</span><span class="n">reuse_if_untouched</span><span class="p">)</span>


<span class="nd">@_replace_division</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Division</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_replace_division_division</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>
    <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">Division</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>


<div class="viewcode-block" id="replace_division">
<a class="viewcode-back" href="../../gem.html#gem.optimise.replace_division">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_division</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace divisions with multiplications in expressions&quot;&quot;&quot;</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">Memoizer</span><span class="p">(</span><span class="n">_replace_division</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">expressions</span><span class="p">))</span></div>



<div class="viewcode-block" id="replace_indices">
<a class="viewcode-back" href="../../gem.html#gem.optimise.replace_indices">[docs]</a>
<span class="nd">@singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_indices</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace free indices in a GEM expression.</span>

<span class="sd">    :arg node: root of the expression</span>
<span class="sd">    :arg self: function for recursive calls</span>
<span class="sd">    :arg subst: tuple of pairs; each pair is a substitution</span>
<span class="sd">                rule with a free index to replace and an index to</span>
<span class="sd">                replace with.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;cannot handle type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>



<span class="n">replace_indices</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span><span class="p">)(</span><span class="n">reuse_if_untouched_arg</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_replace_indices_atomic</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span> <span class="k">if</span> <span class="n">new_expr</span> <span class="o">==</span> <span class="n">i</span><span class="o">.</span><span class="n">expression</span> <span class="k">else</span> <span class="n">VariableIndex</span><span class="p">(</span><span class="n">new_expr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">substitute</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subst</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">substitute</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>


<div class="viewcode-block" id="replace_indices_delta">
<a class="viewcode-back" href="../../gem.html#gem.optimise.replace_indices_delta">[docs]</a>
<span class="nd">@replace_indices</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_indices_delta</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">_replace_indices_atomic</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_replace_indices_atomic</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">j</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Delta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>



<div class="viewcode-block" id="replace_indices_indexed">
<a class="viewcode-back" href="../../gem.html#gem.optimise.replace_indices_indexed">[docs]</a>
<span class="nd">@replace_indices</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Indexed</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_indices_indexed</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">):</span>
    <span class="n">child</span><span class="p">,</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>
    <span class="n">substitute</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subst</span><span class="p">)</span>
    <span class="n">multiindex</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">multiindex</span><span class="p">:</span>
        <span class="n">multiindex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_replace_indices_atomic</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ComponentTensor</span><span class="p">):</span>
        <span class="c1"># Indexing into ComponentTensor</span>
        <span class="c1"># Inline ComponentTensor and augment the substitution rules</span>
        <span class="n">substitute</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">multiindex</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">substitute</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Replace indices</span>
        <span class="n">new_child</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">subst</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_child</span> <span class="o">==</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">multiindex</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">multiindex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">new_child</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">)</span></div>



<div class="viewcode-block" id="replace_indices_flexiblyindexed">
<a class="viewcode-back" href="../../gem.html#gem.optimise.replace_indices_flexiblyindexed">[docs]</a>
<span class="nd">@replace_indices</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">FlexiblyIndexed</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_indices_flexiblyindexed</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">):</span>
    <span class="n">child</span><span class="p">,</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">free_indices</span>

    <span class="n">dim2idxs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">offset</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">else</span> <span class="n">_replace_indices_atomic</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">),</span>
            <span class="nb">tuple</span><span class="p">((</span><span class="n">_replace_indices_atomic</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">),</span> <span class="n">s</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">subst</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">dim2idxs</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">dim2idxs</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">dim2idxs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FlexiblyIndexed</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">dim2idxs</span><span class="p">)</span></div>



<div class="viewcode-block" id="filtered_replace_indices">
<a class="viewcode-back" href="../../gem.html#gem.optimise.filtered_replace_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filtered_replace_indices</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">subst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :func:`replace_indices`.  At each call removes</span>
<span class="sd">    substitution rules that do not apply.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">subst</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Can not replace VariableIndex (will need inverse)&quot;</span><span class="p">)</span>
    <span class="n">filtered_subst</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subst</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">replace_indices</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">filtered_subst</span><span class="p">)</span></div>



<div class="viewcode-block" id="remove_componenttensors">
<a class="viewcode-back" href="../../gem.html#gem.optimise.remove_componenttensors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_componenttensors</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all ComponentTensors in multi-root expression DAG.&quot;&quot;&quot;</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">MemoizerArg</span><span class="p">(</span><span class="n">filtered_replace_indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mapper</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="p">())</span> <span class="k">for</span> <span class="n">expression</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">]</span></div>



<span class="nd">@singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_constant_fold_zero</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;cannot handle type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>


<span class="n">_constant_fold_zero</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span><span class="p">)(</span><span class="n">reuse_if_untouched</span><span class="p">)</span>


<span class="nd">@_constant_fold_zero</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Literal</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_constant_fold_zero_literal</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">array</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="c1"># All zeros, make symbolic zero</span>
        <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>


<span class="nd">@_constant_fold_zero</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ListTensor</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_constant_fold_zero_listtensor</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="n">new_children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="k">for</span> <span class="n">nc</span> <span class="ow">in</span> <span class="n">new_children</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">nc</span> <span class="o">==</span> <span class="n">c</span> <span class="k">for</span> <span class="n">nc</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_children</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="o">*</span><span class="n">new_children</span><span class="p">)</span>


<div class="viewcode-block" id="constant_fold_zero">
<a class="viewcode-back" href="../../gem.html#gem.optimise.constant_fold_zero">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">constant_fold_zero</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Produce symbolic zeros from Literals</span>

<span class="sd">    :arg exprs: An iterable of gem expressions.</span>
<span class="sd">    :returns: A list of gem expressions where any Literal containing</span>
<span class="sd">        only zeros is replaced by symbolic Zero of the appropriate</span>
<span class="sd">        shape.</span>

<span class="sd">    We need a separate path for ListTensor so that its `reconstruct`</span>
<span class="sd">    method will not be called when the new children are `Zero()`s;</span>
<span class="sd">    otherwise Literal `0`s would be reintroduced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">Memoizer</span><span class="p">(</span><span class="n">_constant_fold_zero</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mapper</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">]</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_select_expression</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to select an expression from a list of</span>
<span class="sd">    expressions with an index.  This function expect sanitised input,</span>
<span class="sd">    one should normally call :py:func:`select_expression` instead.</span>

<span class="sd">    :arg expressions: a list of expressions</span>
<span class="sd">    :arg index: an index (free, fixed or variable)</span>
<span class="sd">    :returns: an expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">expressions</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">types</span> <span class="o">&lt;=</span> <span class="p">{</span><span class="n">Indexed</span><span class="p">,</span> <span class="n">Zero</span><span class="p">}:</span>
        <span class="n">multiindex</span><span class="p">,</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">multiindex</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">))</span>
        <span class="c1"># Shape only determined by free indices</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multiindex</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Index</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">child</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">expression</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Zero</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">_select_expression</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">expressions</span><span class="p">)),</span> <span class="n">index</span><span class="p">),</span> <span class="n">multiindex</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">types</span> <span class="o">&lt;=</span> <span class="p">{</span><span class="n">Literal</span><span class="p">,</span> <span class="n">Zero</span><span class="p">,</span> <span class="n">Failure</span><span class="p">}:</span>
        <span class="k">return</span> <span class="n">partial_indexed</span><span class="p">(</span><span class="n">ListTensor</span><span class="p">(</span><span class="n">expressions</span><span class="p">),</span> <span class="p">(</span><span class="n">index</span><span class="p">,))</span>

    <span class="k">if</span> <span class="n">types</span> <span class="o">&lt;=</span> <span class="p">{</span><span class="n">ComponentTensor</span><span class="p">,</span> <span class="n">Zero</span><span class="p">}:</span>
        <span class="n">shape</span><span class="p">,</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">)</span>
        <span class="n">multiindex</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">([</span><span class="n">Indexed</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">multiindex</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">_select_expression</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">multiindex</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="o">=</span> <span class="n">types</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__front__</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__back__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;How to factorise </span><span class="si">{}</span><span class="s2"> expressions?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_select_expression</span><span class="p">(</span><span class="n">nth_children</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">nth_children</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">children</span>
                                                            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">])])</span>

    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No rule for factorising expressions of this kind.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="select_expression">
<a class="viewcode-back" href="../../gem.html#gem.optimise.select_expression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">select_expression</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select an expression from a list of expressions with an index.</span>
<span class="sd">    Semantically equivalent to</span>

<span class="sd">        partial_indexed(ListTensor(expressions), (index,))</span>

<span class="sd">    but has a much more optimised implementation.</span>

<span class="sd">    :arg expressions: a list of expressions of the same shape</span>
<span class="sd">    :arg index: an index (free, fixed or variable)</span>
<span class="sd">    :returns: an expression of the same shape as the given expressions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check arguments</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">shape</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">)</span>

    <span class="c1"># Sanitise input expressions</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Index</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">([</span><span class="n">Indexed</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">])</span>

    <span class="c1"># Factor the expressions recursively and convert result</span>
    <span class="n">selected</span> <span class="o">=</span> <span class="n">_select_expression</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">selected</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span></div>



<div class="viewcode-block" id="delta_elimination">
<a class="viewcode-back" href="../../gem.html#gem.optimise.delta_elimination">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delta_elimination</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;IndexSum-Delta cancellation.</span>

<span class="sd">    :arg sum_indices: free indices for contractions</span>
<span class="sd">    :arg factors: product factors</span>
<span class="sd">    :returns: optimised (sum_indices, factors)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sum_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">)</span>  <span class="c1"># copy for modification</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">substitute</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to_</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">from_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expression</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Delta</span><span class="p">):</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">MemoizerArg</span><span class="p">(</span><span class="n">filtered_replace_indices</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mapper</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="p">((</span><span class="n">from_</span><span class="p">,</span> <span class="n">to_</span><span class="p">),))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">ComponentTensor</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="p">(</span><span class="n">from_</span><span class="p">,)),</span> <span class="p">(</span><span class="n">to_</span><span class="p">,))</span>

    <span class="n">delta_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">f</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Delta</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">j</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">sum_indices</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">delta_queue</span><span class="p">:</span>
        <span class="n">delta</span><span class="p">,</span> <span class="n">from_</span> <span class="o">=</span> <span class="n">delta_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">to_</span><span class="p">,</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">delta</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">j</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="n">from_</span><span class="p">})</span>

        <span class="n">sum_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">from_</span><span class="p">)</span>

        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">substitute</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to_</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">]</span>

        <span class="n">delta_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">f</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">factors</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Delta</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">j</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">sum_indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sum_indices</span><span class="p">,</span> <span class="n">factors</span></div>



<div class="viewcode-block" id="associate">
<a class="viewcode-back" href="../../gem.html#gem.optimise.associate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">associate</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">operands</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply associativity rules to construct an operation-minimal expression tree.</span>

<span class="sd">    For best performance give factors that have different set of free indices.</span>

<span class="sd">    :arg operator: associative binary operator</span>
<span class="sd">    :arg operands: list of operands</span>

<span class="sd">    :returns: (reduced expression, # of floating-point operations)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
        <span class="c1"># O(N^3) algorithm</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not expected such a complicated expression!&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Operation count to reduce a pair of GEM expressions&quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pair</span>
        <span class="n">extents</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">free_indices</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">extents</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">flops</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Greedy algorithm: choose a pair of operands that are the</span>
        <span class="c1"># cheapest to reduce.</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
        <span class="n">flops</span> <span class="o">+=</span> <span class="n">count</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="c1"># Remove chosen factors, append their product</span>
        <span class="n">operands</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">operands</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">result</span><span class="p">,</span> <span class="o">=</span> <span class="n">operands</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">flops</span></div>



<div class="viewcode-block" id="sum_factorise">
<a class="viewcode-back" href="../../gem.html#gem.optimise.sum_factorise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sum_factorise</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimise a tensor product through sum factorisation.</span>

<span class="sd">    :arg sum_indices: free indices for contractions</span>
<span class="sd">    :arg factors: product factors</span>
<span class="sd">    :returns: optimised GEM expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Empty product</span>
        <span class="k">return</span> <span class="n">one</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Too many indices for sum factorisation!&quot;</span><span class="p">)</span>

    <span class="c1"># Form groups by free indices</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>

    <span class="c1"># Sum factorisation</span>
    <span class="n">expression</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">best_flops</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># Consider all orderings of contraction indices</span>
    <span class="k">for</span> <span class="n">ordering</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">):</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[:]</span>
        <span class="n">flops</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Apply contraction index by index</span>
        <span class="k">for</span> <span class="n">sum_index</span> <span class="ow">in</span> <span class="n">ordering</span><span class="p">:</span>
            <span class="c1"># Select terms that need to be part of the contraction</span>
            <span class="n">contract</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">sum_index</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">free_indices</span><span class="p">]</span>
            <span class="n">deferred</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">sum_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">free_indices</span><span class="p">]</span>

            <span class="c1"># Optimise associativity</span>
            <span class="n">product</span><span class="p">,</span> <span class="n">flops_</span> <span class="o">=</span> <span class="n">associate</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="n">contract</span><span class="p">)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">IndexSum</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="p">(</span><span class="n">sum_index</span><span class="p">,))</span>
            <span class="n">flops</span> <span class="o">+=</span> <span class="n">flops_</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">product</span><span class="o">.</span><span class="n">free_indices</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Replace the contracted terms with the result of the</span>
            <span class="c1"># contraction.</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">deferred</span> <span class="o">+</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>

        <span class="c1"># If some contraction indices were independent, then we may</span>
        <span class="c1"># still have several terms at this point.</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">flops_</span> <span class="o">=</span> <span class="n">associate</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span>
        <span class="n">flops</span> <span class="o">+=</span> <span class="n">flops_</span>

        <span class="k">if</span> <span class="n">flops</span> <span class="o">&lt;</span> <span class="n">best_flops</span><span class="p">:</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="n">best_flops</span> <span class="o">=</span> <span class="n">flops</span>

    <span class="k">return</span> <span class="n">expression</span></div>



<div class="viewcode-block" id="make_sum">
<a class="viewcode-back" href="../../gem.html#gem.optimise.make_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_sum</span><span class="p">(</span><span class="n">summands</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constructs an operation-minimal sum of GEM expressions.&quot;&quot;&quot;</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">summands</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>
    <span class="n">summands</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">flops</span> <span class="o">=</span> <span class="n">associate</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span> <span class="n">summands</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="make_product">
<a class="viewcode-back" href="../../gem.html#gem.optimise.make_product">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_product</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="n">sum_indices</span><span class="o">=</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constructs an operation-minimal (tensor) product of GEM expressions.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sum_factorise</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_rename_map">
<a class="viewcode-back" href="../../gem.html#gem.optimise.make_rename_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_rename_map</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates an rename map for reusing the same index renames.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">Index</span><span class="p">)</span></div>



<div class="viewcode-block" id="make_renamer">
<a class="viewcode-back" href="../../gem.html#gem.optimise.make_renamer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_renamer</span><span class="p">(</span><span class="n">rename_map</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Creates a function for renaming indices when expanding products of</span>
<span class="sd">    IndexSums, i.e. applying to following rule:</span>

<span class="sd">        (\sum_i a_i)*(\sum_i b_i) ===&gt; \sum_{i,i&#39;} a_i*b_{i&#39;}</span>

<span class="sd">    :arg rename_map: An rename map for renaming indices the same way</span>
<span class="sd">                     as functions returned by other calls of this</span>
<span class="sd">                     function.</span>
<span class="sd">    :returns: A function that takes an iterable of indices to rename,</span>
<span class="sd">              and returns (renamed indices, applier), where applier is</span>
<span class="sd">              a function that remap the free indices of GEM</span>
<span class="sd">              expressions from the old to the new indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_renamer</span><span class="p">(</span><span class="n">rename_map</span><span class="p">,</span> <span class="n">current_set</span><span class="p">,</span> <span class="n">incoming</span><span class="p">):</span>
        <span class="n">renamed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">renames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">incoming</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">current_set</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">rename_map</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">current_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">renamed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">renames</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">renames</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">applier</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">renames</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_indices</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pairs</span><span class="p">:</span>
                    <span class="n">current</span><span class="p">,</span> <span class="n">renamed</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">pairs</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">ComponentTensor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">current</span><span class="p">),</span> <span class="n">renamed</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">expr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">applier</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">renamed</span><span class="p">),</span> <span class="n">applier</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_renamer</span><span class="p">,</span> <span class="n">rename_map</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span></div>



<div class="viewcode-block" id="traverse_product">
<a class="viewcode-back" href="../../gem.html#gem.optimise.traverse_product">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">traverse_product</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">stop_at</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rename_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Traverses a product tree and collects factors, also descending into</span>
<span class="sd">    tensor contractions (IndexSum).  The nominators of divisions are</span>
<span class="sd">    also broken up, but not the denominators.</span>

<span class="sd">    :arg expression: a GEM expression</span>
<span class="sd">    :arg stop_at: Optional predicate on GEM expressions.  If specified</span>
<span class="sd">                  and returns true for some subexpression, that</span>
<span class="sd">                  subexpression is not broken into further factors</span>
<span class="sd">                  even if it is a product-like expression.</span>
<span class="sd">    :arg rename_map: an rename map for consistent index renaming</span>
<span class="sd">    :returns: (sum_indices, terms)</span>
<span class="sd">              - sum_indices: list of indices to sum over</span>
<span class="sd">              - terms: list of product terms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rename_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rename_map</span> <span class="o">=</span> <span class="n">make_rename_map</span><span class="p">()</span>
    <span class="n">renamer</span> <span class="o">=</span> <span class="n">make_renamer</span><span class="p">(</span><span class="n">rename_map</span><span class="p">)</span>

    <span class="n">sum_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">stop_at</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop_at</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IndexSum</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">applier</span> <span class="o">=</span> <span class="n">renamer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">multiindex</span><span class="p">)</span>
            <span class="n">sum_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">remove_componenttensors</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">applier</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Product</span><span class="p">):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Division</span><span class="p">):</span>
            <span class="c1"># Break up products in the dividend, but not in divisor.</span>
            <span class="n">dividend</span><span class="p">,</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">children</span>
            <span class="k">if</span> <span class="n">dividend</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Division</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">divisor</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dividend</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sum_indices</span><span class="p">,</span> <span class="n">terms</span></div>



<div class="viewcode-block" id="traverse_sum">
<a class="viewcode-back" href="../../gem.html#gem.optimise.traverse_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">traverse_sum</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">stop_at</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Traverses a summation tree and collects summands.</span>

<span class="sd">    :arg expression: a GEM expression</span>
<span class="sd">    :arg stop_at: Optional predicate on GEM expressions.  If specified</span>
<span class="sd">                  and returns true for some subexpression, that</span>
<span class="sd">                  subexpression is not broken into further summands</span>
<span class="sd">                  even if it is an addition.</span>
<span class="sd">    :returns: list of summand expressions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">stop_at</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop_at</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Sum</span><span class="p">):</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="contraction">
<a class="viewcode-back" href="../../gem.html#gem.optimise.contraction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">contraction</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimise the contractions of the tensor product at the root of</span>
<span class="sd">    the expression, including:</span>

<span class="sd">    - IndexSum-Delta cancellation</span>
<span class="sd">    - Sum factorisation</span>

<span class="sd">    :arg ignore: Optional set of indices to ignore when applying sum</span>
<span class="sd">        factorisation (otherwise all summation indices will be</span>
<span class="sd">        considered). Use this if your expression has many contraction</span>
<span class="sd">        indices.</span>

<span class="sd">    This routine was designed with finite element coefficient</span>
<span class="sd">    evaluation in mind.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Eliminate annoying ComponentTensors</span>
    <span class="n">expression</span><span class="p">,</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">([</span><span class="n">expression</span><span class="p">])</span>

    <span class="c1"># Flatten product tree, eliminate deltas, sum factorise</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rebuild</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="n">sum_indices</span><span class="p">,</span> <span class="n">factors</span> <span class="o">=</span> <span class="n">delta_elimination</span><span class="p">(</span><span class="o">*</span><span class="n">traverse_product</span><span class="p">(</span><span class="n">expression</span><span class="p">))</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: This is a really blunt instrument and one might</span>
            <span class="c1"># plausibly want the ignored indices to be contracted on</span>
            <span class="c1"># the inside rather than the outside.</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sum_indices</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">)</span>
            <span class="n">to_factor</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sum_indices</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">IndexSum</span><span class="p">(</span><span class="n">sum_factorise</span><span class="p">(</span><span class="n">to_factor</span><span class="p">,</span> <span class="n">factors</span><span class="p">),</span> <span class="n">extra</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sum_factorise</span><span class="p">(</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>

    <span class="c1"># Sometimes the value shape is composed as a ListTensor, which</span>
    <span class="c1"># could get in the way of decomposing factors.  In particular,</span>
    <span class="c1"># this is the case for H(div) and H(curl) conforming tensor</span>
    <span class="c1"># product elements.  So if ListTensors are used, they are pulled</span>
    <span class="c1"># out to be outermost, so we can straightforwardly factorise each</span>
    <span class="c1"># of its entries.</span>
    <span class="n">lt_fis</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># ListTensor free indices</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">traversal</span><span class="p">((</span><span class="n">expression</span><span class="p">,)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
            <span class="n">child</span><span class="p">,</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ListTensor</span><span class="p">):</span>
                <span class="n">lt_fis</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">zip_longest</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">multiindex</span><span class="p">,</span> <span class="p">()))</span>
    <span class="n">lt_fis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">lt_fis</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">expression</span><span class="o">.</span><span class="n">free_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lt_fis</span><span class="p">:</span>
        <span class="c1"># Rebuild each split component</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">ComponentTensor</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">lt_fis</span><span class="p">)</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">Indexed</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span> <span class="k">for</span> <span class="n">zeta</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">ListTensor</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">rebuild</span><span class="p">,</span> <span class="n">entries</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">lt_fis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Rebuild whole expression at once</span>
        <span class="k">return</span> <span class="n">rebuild</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span></div>



<span class="nd">@singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_replace_delta</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;cannot handle type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>


<span class="n">_replace_delta</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span><span class="p">)(</span><span class="n">reuse_if_untouched</span><span class="p">)</span>


<span class="nd">@_replace_delta</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_replace_delta_delta</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">j</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">i</span><span class="o">.</span><span class="n">extent</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">extent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">i</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">extent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">j</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">extent</span>
        <span class="k">return</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">Identity</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">expression</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Literal</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">VariableIndex</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">expression</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot convert running index to expression.&quot;</span><span class="p">)</span>
        <span class="n">e_i</span> <span class="o">=</span> <span class="n">expression</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">e_j</span> <span class="o">=</span> <span class="n">expression</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Conditional</span><span class="p">(</span><span class="n">Comparison</span><span class="p">(</span><span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="n">e_i</span><span class="p">,</span> <span class="n">e_j</span><span class="p">),</span> <span class="n">one</span><span class="p">,</span> <span class="n">Zero</span><span class="p">())</span>


<div class="viewcode-block" id="replace_delta">
<a class="viewcode-back" href="../../gem.html#gem.optimise.replace_delta">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">replace_delta</span><span class="p">(</span><span class="n">expressions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lowers all Deltas in a multi-root expression DAG.&quot;&quot;&quot;</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">Memoizer</span><span class="p">(</span><span class="n">_replace_delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">expressions</span><span class="p">))</span></div>



<span class="nd">@singledispatch</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_unroll_indexsum</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unrolls IndexSums below a certain extent.</span>

<span class="sd">    :arg node: root of the expression</span>
<span class="sd">    :arg self: function for recursive calls</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;cannot handle type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>


<span class="n">_unroll_indexsum</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Node</span><span class="p">)(</span><span class="n">reuse_if_untouched</span><span class="p">)</span>


<span class="nd">@_unroll_indexsum</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">IndexSum</span><span class="p">)</span>  <span class="c1"># noqa</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
    <span class="n">unroll</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicate</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">multiindex</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">unroll</span><span class="p">:</span>
        <span class="c1"># Unrolling</span>
        <span class="n">summand</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">extent</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">unroll</span><span class="p">)</span>
        <span class="n">unrolled</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">Sum</span><span class="p">,</span>
                          <span class="p">(</span><span class="n">Indexed</span><span class="p">(</span><span class="n">ComponentTensor</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="n">unroll</span><span class="p">),</span> <span class="n">alpha</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span>
                          <span class="n">Zero</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">IndexSum</span><span class="p">(</span><span class="n">unrolled</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">multiindex</span>
                                        <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unroll</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reuse_if_untouched</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="unroll_indexsum">
<a class="viewcode-back" href="../../gem.html#gem.optimise.unroll_indexsum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unroll_indexsum</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unrolls IndexSums below a specified extent.</span>

<span class="sd">    :arg expressions: list of expression DAGs</span>
<span class="sd">    :arg predicate: a predicate function on :py:class:`Index` objects</span>
<span class="sd">                    that tells whether to unroll a particular index</span>
<span class="sd">    :returns: list of expression DAGs with some unrolled IndexSums</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mapper</span> <span class="o">=</span> <span class="n">Memoizer</span><span class="p">(</span><span class="n">_unroll_indexsum</span><span class="p">)</span>
    <span class="n">mapper</span><span class="o">.</span><span class="n">predicate</span> <span class="o">=</span> <span class="n">predicate</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">expressions</span><span class="p">))</span></div>



<div class="viewcode-block" id="aggressive_unroll">
<a class="viewcode-back" href="../../gem.html#gem.optimise.aggressive_unroll">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">aggressive_unroll</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Aggressively unrolls all loop structures.&quot;&quot;&quot;</span>
    <span class="c1"># Unroll expression shape</span>
    <span class="k">if</span> <span class="n">expression</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">expression</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">tensor</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="n">Indexed</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">expression</span><span class="p">,</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">((</span><span class="n">ListTensor</span><span class="p">(</span><span class="n">tensor</span><span class="p">),))</span>

    <span class="c1"># Unroll summation</span>
    <span class="n">expression</span><span class="p">,</span> <span class="o">=</span> <span class="n">unroll_indexsum</span><span class="p">((</span><span class="n">expression</span><span class="p">,),</span> <span class="n">predicate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">index</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">expression</span><span class="p">,</span> <span class="o">=</span> <span class="n">remove_componenttensors</span><span class="p">((</span><span class="n">expression</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">expression</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">gem.optimise</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, FEniCS Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>