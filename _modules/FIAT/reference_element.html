<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FIAT.reference_element &#8212; FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=2bf1fcf8" />
    
    <script src="../../_static/documentation_options.js?v=e952a2db"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">FIAT.reference_element</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for FIAT.reference_element</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2008 Robert C. Kirby (Texas Tech University)</span>
<span class="c1">#</span>
<span class="c1"># This file is part of FIAT (https://www.fenicsproject.org)</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier:    LGPL-3.0-or-later</span>
<span class="c1">#</span>
<span class="c1"># Modified by David A. Ham (david.ham@imperial.ac.uk), 2014</span>
<span class="c1"># Modified by Lizao Li (lzlarryli@gmail.com), 2016</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Abstract class and particular implementations of finite element</span>
<span class="sd">reference simplex geometry/topology.</span>

<span class="sd">Provides an abstract base class and particular implementations for the</span>
<span class="sd">reference simplex geometry and topology.</span>
<span class="sd">The rest of FIAT is abstracted over this module so that different</span>
<span class="sd">reference element geometry (e.g. a vertex at (0,0) versus at (-1,-1))</span>
<span class="sd">and orderings of entities have a single point of entry.</span>

<span class="sd">Currently implemented are UFC and Default Line, Triangle and Tetrahedron.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">factorial</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">recursivenodes.nodes</span><span class="w"> </span><span class="kn">import</span> <span class="n">_decode_family</span><span class="p">,</span> <span class="n">_recursive</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">FIAT.orientation_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Orientation</span><span class="p">,</span>
    <span class="n">make_cell_orientation_reflection_map_simplex</span><span class="p">,</span>
    <span class="n">make_cell_orientation_reflection_map_tensorproduct</span><span class="p">,</span>
    <span class="n">make_entity_permutations_simplex</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">POINT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">LINE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">TRIANGLE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">TETRAHEDRON</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">QUADRILATERAL</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">HEXAHEDRON</span> <span class="o">=</span> <span class="mi">111</span>
<span class="n">TENSORPRODUCT</span> <span class="o">=</span> <span class="mi">99</span>


<div class="viewcode-block" id="multiindex_equal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.multiindex_equal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">multiindex_equal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">isum</span><span class="p">,</span> <span class="n">imin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generator for d-tuple multi-indices whose sum is isum and minimum is imin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">imax</span> <span class="o">=</span> <span class="n">isum</span> <span class="o">-</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">imin</span>
    <span class="k">if</span> <span class="n">imax</span> <span class="o">&lt;</span> <span class="n">imin</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">multiindex_equal</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isum</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">imin</span><span class="o">=</span><span class="n">imin</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">imin</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">imax</span><span class="p">,)</span></div>



<div class="viewcode-block" id="lattice_iter">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.lattice_iter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lattice_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generator iterating over the depth-dimensional lattice of</span>
<span class="sd">    integers between start and (finish-1).  This works on simplices in</span>
<span class="sd">    0d, 1d, 2d, 3d, and beyond&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">ii</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">lattice_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">ii</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">jj</span> <span class="o">+</span> <span class="p">(</span><span class="n">ii</span><span class="p">,)</span></div>



<div class="viewcode-block" id="make_lattice">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.make_lattice">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_lattice</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">interior</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constructs a lattice of points on the simplex defined by verts.</span>
<span class="sd">    For example, the 1:st order lattice will be just the vertices.</span>
<span class="sd">    The optional argument interior specifies how many points from</span>
<span class="sd">    the boundary to omit.  For example, on a line with n = 2,</span>
<span class="sd">    and interior = 0, this function will return the vertices and</span>
<span class="sd">    midpoint, but with interior = 1, it will only return the</span>
<span class="sd">    midpoint.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">variant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">variant</span> <span class="o">=</span> <span class="s2">&quot;equispaced&quot;</span>
    <span class="n">recursivenodes_families</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;equispaced&quot;</span><span class="p">:</span> <span class="s2">&quot;equi&quot;</span><span class="p">,</span>
        <span class="s2">&quot;equispaced_interior&quot;</span><span class="p">:</span> <span class="s2">&quot;equi_interior&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gll&quot;</span><span class="p">:</span> <span class="s2">&quot;lgl&quot;</span><span class="p">}</span>
    <span class="n">family</span> <span class="o">=</span> <span class="n">recursivenodes_families</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">variant</span><span class="p">,</span> <span class="n">variant</span><span class="p">)</span>
    <span class="n">family</span> <span class="o">=</span> <span class="n">_decode_family</span><span class="p">(</span><span class="n">family</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
    <span class="n">get_point</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_recursive</span><span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">family</span><span class="p">),</span> <span class="n">X</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_point</span><span class="p">,</span> <span class="n">multiindex_equal</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">interior</span><span class="p">)))</span></div>



<div class="viewcode-block" id="linalg_subspace_intersection">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.linalg_subspace_intersection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">linalg_subspace_intersection</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the intersection of the subspaces spanned by the</span>
<span class="sd">    columns of 2-dimensional arrays A,B using the algorithm found in</span>
<span class="sd">    Golub and van Loan (3rd ed) p. 604.  A should be in</span>
<span class="sd">    R^{m,p} and B should be in R^{m,q}.  Returns an orthonormal basis</span>
<span class="sd">    for the intersection of the spaces, stored in the columns of</span>
<span class="sd">    the result.&quot;&quot;&quot;</span>

    <span class="c1"># check that vectors are in same space</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Dimension error&quot;</span><span class="p">)</span>

    <span class="c1"># A,B are matrices of column vectors</span>
    <span class="c1"># compute the intersection of span(A) and span(B)</span>

    <span class="c1"># Compute the principal vectors/angles between the subspaces, G&amp;vL</span>
    <span class="c1"># p.604</span>
    <span class="p">(</span><span class="n">qa</span><span class="p">,</span> <span class="n">_ra</span><span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="p">(</span><span class="n">qb</span><span class="p">,</span> <span class="n">_rb</span><span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">qa</span><span class="p">),</span> <span class="n">qb</span><span class="p">)</span>

    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_zt</span><span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">qa</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">rank_c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">c</span> <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-10</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">U</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rank_c</span><span class="p">]</span></div>



<div class="viewcode-block" id="Cell">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Cell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract class for a reference cell.  Provides accessors for</span>
<span class="sd">    geometry (vertex coordinates) as well as topology (orderings of</span>
<span class="sd">    vertices that make up edges, faces, etc.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The constructor takes a shape code, the physical vertices expressed</span>
<span class="sd">        as a list of tuples of numbers, and the topology of a cell.</span>

<span class="sd">        The topology is stored as a dictionary of dictionaries t[i][j]</span>
<span class="sd">        where i is the dimension and j is the index of the facet of</span>
<span class="sd">        that dimension.  The result is a list of the vertices</span>
<span class="sd">        comprising the facet.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>

        <span class="c1"># Given the topology, work out for each entity in the cell,</span>
        <span class="c1"># which other entities it contains.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_entities</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entities</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub_entities</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">entities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">sub_entities</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">dim_</span><span class="p">,</span> <span class="n">entities_</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">e_</span><span class="p">,</span> <span class="n">vertices_</span> <span class="ow">in</span> <span class="n">entities_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">vertices</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">vertices_</span><span class="p">):</span>
                            <span class="n">sub_entities</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dim_</span><span class="p">,</span> <span class="n">e_</span><span class="p">))</span>

                <span class="c1"># Sort for the sake of determinism and by UFC conventions</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sub_entities</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sub_entities</span><span class="p">)</span>

        <span class="c1"># Build super-entity dictionary by inverting the sub-entity dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_entities</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="p">{</span><span class="n">entity</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">]}</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">dim0</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e0</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">[</span><span class="n">dim0</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">dim1</span><span class="p">,</span> <span class="n">e1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_entities</span><span class="p">[</span><span class="n">dim0</span><span class="p">][</span><span class="n">e0</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">super_entities</span><span class="p">[</span><span class="n">dim1</span><span class="p">][</span><span class="n">e1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dim0</span><span class="p">,</span> <span class="n">e0</span><span class="p">))</span>

        <span class="c1"># Build connectivity dictionary for easier queries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim0</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim1</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">dim0</span><span class="p">,</span> <span class="n">dim1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology</span><span class="p">[</span><span class="n">dim0</span><span class="p">]):</span>
                <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_entities</span><span class="p">[</span><span class="n">dim0</span><span class="p">][</span><span class="n">entity</span><span class="p">]</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_entities</span><span class="p">[</span><span class="n">dim0</span><span class="p">][</span><span class="n">entity</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">dim1</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology</span><span class="p">):</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">children</span> <span class="k">if</span> <span class="n">dim1</span> <span class="o">&lt;</span> <span class="n">dim0</span> <span class="k">else</span> <span class="n">parents</span>
                    <span class="n">d01_entities</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">dim1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">dim0</span><span class="p">,</span> <span class="n">dim1</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d01_entities</span><span class="p">)</span>

        <span class="c1"># Dictionary with derived cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hashable object key data (excluding type).&quot;&quot;&quot;</span>
        <span class="c1"># Default: only type matters</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span><span class="p">()))</span>

<div class="viewcode-block" id="Cell.get_shape">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the code for the element&#39;s shape.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span></div>


<div class="viewcode-block" id="Cell.get_vertices">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an iterable of the element&#39;s vertices, each stored as a</span>
<span class="sd">        tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span></div>


<div class="viewcode-block" id="Cell.get_spatial_dimension">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_spatial_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_spatial_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the spatial dimension in which the element lives.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="Cell.get_topology">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_topology">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a dictionary encoding the topology of the element.</span>

<span class="sd">        The dictionary&#39;s keys are the spatial dimensions (0, 1, ...)</span>
<span class="sd">        and each value is a dictionary mapping.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span></div>


<div class="viewcode-block" id="Cell.get_connectivity">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_connectivity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a dictionary encoding the connectivity of the element.</span>

<span class="sd">        The dictionary&#39;s keys are the spatial dimensions pairs ((1, 0),</span>
<span class="sd">        (2, 0), (2, 1), ...) and each value is a list with entities</span>
<span class="sd">        of second dimension ordered by local dim0-dim1 numbering.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span></div>


<div class="viewcode-block" id="Cell.get_vertices_of_subcomplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_vertices_of_subcomplex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_vertices_of_subcomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the tuple of vertex coordinates associated with the labels</span>
<span class="sd">        contained in the iterable t.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span> <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.get_dimension">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the subelement dimension of the cell.  For tensor</span>
<span class="sd">        product cells, this a tuple of dimensions for each cell in the</span>
<span class="sd">        product.  For all other cells, this is the same as the spatial</span>
<span class="sd">        dimension.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: `tuple` for tensor product cells, `int` otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.construct_subcomplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.construct_subcomplex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subcomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference subcomplex of the parent cell subentity</span>
<span class="sd">        specified by subcomplex dimension.</span>

<span class="sd">        :arg dimension: `tuple` for tensor product cells, `int` otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_subelement</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.get_entity_transform">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_entity_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_entity_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a mapping of point coordinates from the</span>
<span class="sd">        `entity_i`-th subentity of dimension `dim` to the cell.</span>

<span class="sd">        :arg dim: `tuple` for tensor product cells, `int` otherwise</span>
<span class="sd">        :arg entity_i: entity number (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.symmetry_group_size">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.symmetry_group_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry_group_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the size of the symmetry group of an entity of</span>
<span class="sd">        dimension `dim`.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.cell_orientation_reflection_map">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.cell_orientation_reflection_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_orientation_reflection_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the map indicating whether each possible cell orientation causes reflection (``1``) or not (``0``).&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.extract_extrinsic_orientation">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.extract_extrinsic_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_extrinsic_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract extrinsic orientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : Orientation</span>
<span class="sd">            Total orientation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Orientation</span>
<span class="sd">            Extrinsic orientation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.extract_intrinsic_orientation">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.extract_intrinsic_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_intrinsic_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract intrinsic orientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : Orientation</span>
<span class="sd">            Total orientation.</span>
<span class="sd">        axis : int</span>
<span class="sd">            Reference cell axis for which intrinsic orientation is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Orientation</span>
<span class="sd">            Intrinsic orientation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrinsic_orientation_permutation_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A map from extrinsic orientations to corresponding axis permutation matrices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        result[eo] gives the physical axis-reference axis permutation matrix corresponding to</span>
<span class="sd">        eo (extrinsic orientation).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Should be implemented in a subclass.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Cell.is_simplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.is_simplex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_simplex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Cell.is_macrocell">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.is_macrocell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_macrocell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Cell.get_interior_facets">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_interior_facets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_interior_facets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the interior facets this cell is a split and () otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">()</span></div>


<div class="viewcode-block" id="Cell.get_parent">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_parent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parent cell if this cell is a split and None otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Cell.get_parent_complex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.get_parent_complex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parent complex if this cell is a split and None otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Cell.is_parent">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Cell.is_parent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether this cell is the parent of the other cell.&quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_parent_complex</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">parent</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_parent_complex</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">atop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">btop</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">atop</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">atop</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">btop</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">is_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_parent</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">is_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_parent</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="SimplicialComplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SimplicialComplex</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Abstract class for a simplicial complex.</span>

<span class="sd">    This consists of list of vertex locations and a topology map defining facets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
        <span class="c1"># Make sure that every facet has the right number of vertices to be</span>
        <span class="c1"># a simplex.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">entity</span><span class="p">])</span> <span class="o">==</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

<div class="viewcode-block" id="SimplicialComplex.compute_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the unit normal vector to facet i of codimension 1.&quot;&quot;&quot;</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>

        <span class="c1"># To handle simplicial complex case:</span>
        <span class="c1"># Find a subcell of which facet_i is on the boundary</span>
        <span class="c1"># Note: this is trivial and vastly overengineered for the single-cell</span>
        <span class="c1"># case.</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">facets</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                        <span class="k">if</span> <span class="n">facet_i</span> <span class="ow">in</span> <span class="n">facets</span><span class="p">)</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">sd</span><span class="p">][</span><span class="n">cell</span><span class="p">]))</span>
        <span class="c1"># Interval case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape</span><span class="p">()</span> <span class="o">==</span> <span class="n">LINE</span><span class="p">:</span>
            <span class="n">v_i</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">cell</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">facet_i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">v_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">verts</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="n">v_i</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># vectors from vertex 0 to each other vertex.</span>
        <span class="n">vert_vecs_from_v0</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">verts</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">vert_vecs_from_v0</span><span class="p">)</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">si</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">si</span> <span class="o">&gt;</span> <span class="mf">1.e-10</span><span class="p">])</span>

        <span class="c1"># this is the set of vectors that span the simplex</span>
        <span class="n">spanu</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rank</span><span class="p">]</span>

        <span class="n">vert_coords_of_facet</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">sd</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">facet_i</span><span class="p">])</span>

        <span class="c1"># now I find everything normal to the facet.</span>
        <span class="n">vcf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vert_coords_of_facet</span><span class="p">)</span>
        <span class="n">facet_span</span> <span class="o">=</span> <span class="n">vcf</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vcf</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">vft</span><span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">facet_span</span><span class="p">)</span>

        <span class="c1"># now get the null space from vft</span>
        <span class="n">rankfacet</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">si</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">sf</span> <span class="k">if</span> <span class="n">si</span> <span class="o">&gt;</span> <span class="mf">1.e-10</span><span class="p">])</span>
        <span class="n">facet_normal_space</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vft</span><span class="p">[</span><span class="n">rankfacet</span><span class="p">:,</span> <span class="p">:])</span>

        <span class="c1"># now, I have to compute the intersection of</span>
        <span class="c1"># facet_span with facet_normal_space</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="n">linalg_subspace_intersection</span><span class="p">(</span><span class="n">facet_normal_space</span><span class="p">,</span> <span class="n">spanu</span><span class="p">)</span>

        <span class="n">num_cols</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">num_cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;barf in normal computation&quot;</span><span class="p">)</span>

        <span class="c1"># now need to get the correct sign</span>
        <span class="c1"># get a vector in the direction</span>
        <span class="n">nfoo</span> <span class="o">=</span> <span class="n">foo</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># what is the vertex not in the facet?</span>
        <span class="n">verts_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">sd</span><span class="p">][</span><span class="n">cell</span><span class="p">])</span>
        <span class="n">verts_facet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">sd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">facet_i</span><span class="p">])</span>
        <span class="n">verts_diff</span> <span class="o">=</span> <span class="n">verts_set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">verts_facet</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts_diff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;barf in normal computation: getting sign&quot;</span><span class="p">)</span>
        <span class="n">vert_off</span> <span class="o">=</span> <span class="n">verts_diff</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">vert_on</span> <span class="o">=</span> <span class="n">verts_facet</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># get a vector from the off vertex to the facet</span>
        <span class="n">v_to_facet</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vert_on</span><span class="p">])</span> \
            <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vert_off</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_to_facet</span><span class="p">,</span> <span class="n">nfoo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nfoo</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">nfoo</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_tangents">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_tangents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_tangents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes tangents in any dimension based on differences</span>
<span class="sd">        between vertices and the first vertex of the i:th facet</span>
<span class="sd">        of dimension dim.  Returns a (possibly empty) list.</span>
<span class="sd">        These tangents are *NOT* normalized to have unit length.&quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">vs</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_normalized_tangents">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_normalized_tangents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_normalized_tangents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes tangents in any dimension based on differences</span>
<span class="sd">        between vertices and the first vertex of the i:th facet</span>
<span class="sd">        of dimension dim.  Returns a (possibly empty) list.</span>
<span class="sd">        These tangents are normalized to have unit length.&quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_tangents</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_edge_tangent">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_edge_tangent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_edge_tangent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the nonnormalized tangent to a 1-dimensional facet.</span>
<span class="sd">        returns a single vector.&quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">edge_i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_normalized_edge_tangent">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_normalized_edge_tangent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_normalized_edge_tangent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the unit tangent vector to a 1-dimensional facet&quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_edge_tangent</span><span class="p">(</span><span class="n">edge_i</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">/=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_face_tangents">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_face_tangents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_face_tangents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the two tangents to a face.  Only implemented</span>
<span class="sd">        for a tetrahedron.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;can&#39;t get face tangents yet&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">face_i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">vs</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_face_edge_tangents">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_face_edge_tangents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_face_edge_tangents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes all the edge tangents of any k-face with k&gt;=1.</span>
<span class="sd">        The result is a array of binom(dim+1,2) vectors.</span>
<span class="sd">        This agrees with `compute_edge_tangent` when dim=1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vert_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()[</span><span class="n">dim</span><span class="p">][</span><span class="n">entity_id</span><span class="p">]</span>
        <span class="n">vert_coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">vert_ids</span><span class="p">))</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">v0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">v1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vert_coords</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vert_coords</span><span class="p">[</span><span class="n">v0</span><span class="p">]</span></div>


<div class="viewcode-block" id="SimplicialComplex.make_points">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.make_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity_id</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interior</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs a lattice of points on the entity_id:th</span>
<span class="sd">        facet of dimension dim.  Order indicates how many points to</span>
<span class="sd">        include in each direction.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()[</span><span class="n">entity_id</span><span class="p">],</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">dim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">():</span>
            <span class="n">entity_verts</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()[</span><span class="n">dim</span><span class="p">][</span><span class="n">entity_id</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">make_lattice</span><span class="p">(</span><span class="n">entity_verts</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">interior</span><span class="o">=</span><span class="n">interior</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="n">variant</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;illegal dimension&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimplicialComplex.volume">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.volume">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the volume of the simplicial complex in the appropriate</span>
<span class="sd">        dimensional measure.&quot;&quot;&quot;</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_of_subcomplex</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">[</span><span class="n">sd</span><span class="p">])</span></div>


<div class="viewcode-block" id="SimplicialComplex.volume_of_subcomplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.volume_of_subcomplex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume_of_subcomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">facet_no</span><span class="p">):</span>
        <span class="n">vids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">facet_no</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">vids</span><span class="p">))</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_scaled_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_scaled_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_scaled_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the unit normal to facet_i of scaled by the</span>
<span class="sd">        volume of that facet.&quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume_of_subcomplex</span><span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_normal</span><span class="p">(</span><span class="n">facet_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_reference_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_reference_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_reference_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_dim</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the unit normal in infinity norm to facet_i.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">facet_dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">compute_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">)</span>  <span class="c1"># skip UFC overrides</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimplicialComplex.get_entity_transform">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.get_entity_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_entity_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a mapping of point coordinates from the</span>
<span class="sd">        `entity`-th subentity of dimension `dim` to the cell.</span>

<span class="sd">        :arg dim: subentity dimension (integer)</span>
<span class="sd">        :arg entity: entity number (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">celldim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>
        <span class="n">codim</span> <span class="o">=</span> <span class="n">celldim</span> <span class="o">-</span> <span class="n">dim</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Special case vertices.</span>
            <span class="n">i</span><span class="p">,</span> <span class="o">=</span> <span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">entity</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="n">celldim</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">[</span><span class="n">celldim</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">entity</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_subelement</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">subdim</span> <span class="o">=</span> <span class="n">subcell</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">subdim</span> <span class="o">==</span> <span class="n">celldim</span> <span class="o">-</span> <span class="n">codim</span>

            <span class="c1"># Entity vertices in entity space.</span>
            <span class="n">v_e</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">subcell</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">())</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">v_e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">v_e</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Entity vertices in cell space.</span>
            <span class="n">v_c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">entity</span><span class="p">]))</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">v_c</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">v_c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">C</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

            <span class="n">offset</span> <span class="o">=</span> <span class="n">v_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v_e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transform</span></div>


<div class="viewcode-block" id="SimplicialComplex.get_dimension">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.get_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the subelement dimension of the cell.  Same as the</span>
<span class="sd">        spatial dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_barycentric_coordinates">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_barycentric_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_barycentric_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the barycentric coordinates of a list of points on the complex.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="k">if</span> <span class="n">entity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">entity_dim</span><span class="p">,</span> <span class="n">entity_id</span> <span class="o">=</span> <span class="n">entity</span>
        <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>

        <span class="c1"># get a subcell containing the entity and the restriction indices of the entity</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">subcomplex</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="n">entity_dim</span><span class="p">][</span><span class="n">entity_id</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">entity_dim</span> <span class="o">!=</span> <span class="n">sd</span><span class="p">:</span>
            <span class="n">cell_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[(</span><span class="n">entity_dim</span><span class="p">,</span> <span class="n">sd</span><span class="p">)][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">sd</span><span class="p">][</span><span class="n">cell_id</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subcomplex</span><span class="p">]</span>
            <span class="n">subcomplex</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="n">sd</span><span class="p">][</span><span class="n">cell_id</span><span class="p">]</span>

        <span class="n">cell_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertices_of_subcomplex</span><span class="p">(</span><span class="n">subcomplex</span><span class="p">)</span>
        <span class="n">ref_verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">make_affine_mapping</span><span class="p">(</span><span class="n">cell_verts</span><span class="p">,</span> <span class="n">ref_verts</span><span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rescale</span><span class="p">:</span>
            <span class="c1"># rescale barycentric coordinates by the height wrt. to the facet</span>
            <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">*=</span> <span class="n">h</span>
            <span class="n">A</span> <span class="o">*=</span> <span class="n">h</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimplicialComplex.compute_bubble">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.compute_bubble">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_bubble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the lowest-order bubble on an entity evaluated at the given</span>
<span class="sd">        points on the cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_barycentric_coordinates</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">entity</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimplicialComplex.distance_to_point_l1">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.distance_to_point_l1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_to_point_l1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># noqa: D301</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the L1 distance (aka &#39;manhatten&#39;, &#39;taxicab&#39; or rectilinear</span>
<span class="sd">        distance) from an entity to a point with 0.0 if the point is inside the entity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : numpy.ndarray or list</span>
<span class="sd">            The coordinates of the points.</span>
<span class="sd">        entity : tuple or None</span>
<span class="sd">            A tuple of entity dimension and entity id.</span>
<span class="sd">        rescale : bool</span>
<span class="sd">            If true, the L1 distance is measured with respect to rescaled</span>
<span class="sd">            barycentric coordinates, such that the L1 and L2 distances agree</span>
<span class="sd">            for points opposite to a single facet.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.float64 or numpy.ndarray</span>
<span class="sd">            The L1 distance, also known as taxicab, manhatten or rectilinear</span>
<span class="sd">            distance, of the cell to the point. If 0.0 the point is inside the</span>
<span class="sd">            cell.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This is done with the help of barycentric coordinates where the general</span>
<span class="sd">        algorithm is to compute the most negative (i.e. minimum) barycentric</span>
<span class="sd">        coordinate then return its negative. For implementation reasons we</span>
<span class="sd">        return the sum of all the negative barycentric coordinates. In each of</span>
<span class="sd">        the below examples the point coordinate is `X` with appropriate</span>
<span class="sd">        dimensions.</span>

<span class="sd">        Consider, for example, a UFCInterval. We have two vertices which make</span>
<span class="sd">        the interval,</span>
<span class="sd">            `P0 = [0]` and</span>
<span class="sd">            `P1 = [1]`.</span>
<span class="sd">        Our point is</span>
<span class="sd">            `X = [x]`.</span>
<span class="sd">        Barycentric coordinates are defined as</span>
<span class="sd">            `X = alpha * P0 + beta * P1` where</span>
<span class="sd">            `alpha + beta = 1.0`.</span>
<span class="sd">        The solution is</span>
<span class="sd">            `alpha = 1 - X[0] = 1 - x` and</span>
<span class="sd">            `beta = X[0] = x`.</span>
<span class="sd">        If both `alpha` and `beta` are positive, the point is inside the</span>
<span class="sd">        reference interval.</span>

<span class="sd">        `---regionA---P0=0------P1=1---regionB---`</span>

<span class="sd">        If we are in `regionA`, `alpha` is negative and</span>
<span class="sd">        `-alpha = X[0] - 1.0` is the (positive) distance from `P0`.</span>
<span class="sd">        If we are in `regionB`, `beta` is negative and `-beta = -X[0]` is</span>
<span class="sd">        the exact (positive) distance from `P1`. Since we are in 1D the L1</span>
<span class="sd">        distance is the same as the L2 distance. If we are in the interval we</span>
<span class="sd">        can just return 0.0.</span>

<span class="sd">        Things get more complicated when we consider higher dimensions.</span>
<span class="sd">        Consider a UFCTriangle. We have three vertices which make the</span>
<span class="sd">        reference triangle,</span>
<span class="sd">            `P0 = (0, 0)`,</span>
<span class="sd">            `P1 = (1, 0)` and</span>
<span class="sd">            `P2 = (0, 1)`.</span>
<span class="sd">        Our point is</span>
<span class="sd">            `X = [x, y]`.</span>
<span class="sd">        Below is a diagram of the cell (which may not render correctly in</span>
<span class="sd">        sphinx):</span>

<span class="sd">        .. code-block:: text</span>
<span class="sd">        ```</span>
<span class="sd">                y-axis</span>
<span class="sd">                |</span>
<span class="sd">                |</span>
<span class="sd">          (0,1) P2</span>
<span class="sd">                | \\</span>
<span class="sd">                |  \\</span>
<span class="sd">                |   \\</span>
<span class="sd">                |    \\</span>
<span class="sd">                |  T  \\</span>
<span class="sd">                |      \\</span>
<span class="sd">                |       \\</span>
<span class="sd">                |        \\</span>
<span class="sd">            ---P0--------P1--- x-axis</span>
<span class="sd">          (0,0) |         (1,0)</span>
<span class="sd">        ```</span>

<span class="sd">        Barycentric coordinates are defined as</span>
<span class="sd">            `X = alpha * P0 + beta * P1 + gamma * P2` where</span>
<span class="sd">            `alpha + beta + gamma = 1.0`.</span>
<span class="sd">        The solution is</span>
<span class="sd">            `alpha = 1 - X[0] - X[1] = 1 - x - y`,</span>
<span class="sd">            `beta = X[0] = x` and</span>
<span class="sd">            `gamma = X[1] = y`.</span>
<span class="sd">        If all three are positive, the point is inside the reference cell.</span>
<span class="sd">        If any are negative, we are outside it. The absolute sum of any</span>
<span class="sd">        negative barycentric coordinates usefully gives the L1 distance from</span>
<span class="sd">        the cell to the point. For example the point (1,1) has L1 distance</span>
<span class="sd">        1 from the cell: on this case alpha = -1, beta = 1 and gamma = 1.</span>
<span class="sd">        -alpha = 1 is the L1 distance. For comparison the L2 distance (the</span>
<span class="sd">        length of the vector from the nearest point on the cell to the point)</span>
<span class="sd">        is sqrt(0.5^2 + 0.5^2) = 0.707. Similarly the point (-1.0, -1.0) has</span>
<span class="sd">        alpha = 3, beta = -1 and gamma = -1. The absolute sum of beta and gamma</span>
<span class="sd">        2 which is again the L1 distance. The L2 distance in this case is</span>
<span class="sd">        sqrt(1^2 + 1^2) = 1.414.</span>

<span class="sd">        For a UFCTetrahedron we have four vertices</span>
<span class="sd">            `P0 = (0,0,0)`,</span>
<span class="sd">            `P1 = (1,0,0)`,</span>
<span class="sd">            `P2 = (0,1,0)` and</span>
<span class="sd">            `P3 = (0,0,1)`.</span>
<span class="sd">        Our point is</span>
<span class="sd">            `X = [x, y, z]`.</span>
<span class="sd">        The barycentric coordinates are defined as</span>
<span class="sd">            `X = alpha * P0 + beta * P1 + gamma * P2 + delta * P3`</span>
<span class="sd">            where</span>
<span class="sd">            `alpha + beta + gamma + delta = 1.0`.</span>
<span class="sd">        The solution is</span>
<span class="sd">            `alpha = 1 - X[0] - X[1] - X[2] = 1 - x - y - z`,</span>
<span class="sd">            `beta = X[0] = x`,</span>
<span class="sd">            `gamma = X[1] = y` and</span>
<span class="sd">            `delta = X[2] = z`.</span>
<span class="sd">        The rules are the same as for the tetrahedron but with one extra</span>
<span class="sd">        barycentric coordinate. Our approximate distance, the absolute sum of</span>
<span class="sd">        the negative barycentric coordinates, is at worse around 4 times the</span>
<span class="sd">        actual distance to the tetrahedron.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sum the negative part of each barycentric coordinate</span>
        <span class="n">bary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_barycentric_coordinates</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="n">entity</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">bary</span><span class="p">)</span> <span class="o">-</span> <span class="n">bary</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="SimplicialComplex.contains_point">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.contains_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if reference cell contains given point</span>
<span class="sd">        (with numerical tolerance as given by the L1 distance (aka &#39;manhatten&#39;,</span>
<span class="sd">        &#39;taxicab&#39; or rectilinear distance) to the cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : numpy.ndarray, list or symbolic expression</span>
<span class="sd">            The coordinates of the point.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            The tolerance for the check.</span>
<span class="sd">        entity : tuple or None</span>
<span class="sd">            A tuple of entity dimension and entity id.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if the point is inside the cell, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_point_l1</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">entity</span><span class="o">=</span><span class="n">entity</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span></div>


<div class="viewcode-block" id="SimplicialComplex.extract_extrinsic_orientation">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.extract_extrinsic_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_extrinsic_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract extrinsic orientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : Orientation</span>
<span class="sd">            Total orientation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Orientation</span>
<span class="sd">            Extrinsic orientation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting an instance of Orientation : got </span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="SimplicialComplex.extract_intrinsic_orientation">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SimplicialComplex.extract_intrinsic_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_intrinsic_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract intrinsic orientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : Orientation</span>
<span class="sd">            Total orientation.</span>
<span class="sd">        axis : int</span>
<span class="sd">            Reference cell axis for which intrinsic orientation is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Orientation</span>
<span class="sd">            Intrinsic orientation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting an instance of Orientation : got </span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis (</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">) != 0&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">o</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrinsic_orientation_permutation_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A map from extrinsic orientations to corresponding axis permutation matrices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        result[eo] gives the physical axis-reference axis permutation matrix corresponding to</span>
<span class="sd">        eo (extrinsic orientation).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>



<div class="viewcode-block" id="Simplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Simplex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Simplex</span><span class="p">(</span><span class="n">SimplicialComplex</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Abstract class for a reference simplex.</span>

<span class="sd">    Orientation of a physical cell is computed systematically</span>
<span class="sd">    by comparing the canonical orderings of its facets and</span>
<span class="sd">    the facets in the FIAT reference cell.</span>

<span class="sd">    As an example, we compute the orientation of a</span>
<span class="sd">    triangular cell:</span>

<span class="sd">       +                    +</span>
<span class="sd">       | \                  | \</span>
<span class="sd">       1   0               47   42</span>
<span class="sd">       |     \              |     \</span>
<span class="sd">       +--2---+             +--43--+</span>
<span class="sd">    FIAT canonical     Mapped example physical cell</span>

<span class="sd">    Suppose that the facets of the physical cell</span>
<span class="sd">    are canonically ordered as:</span>

<span class="sd">    C = [43, 42, 47]</span>

<span class="sd">    FIAT facet to Physical facet map is given by:</span>

<span class="sd">    M = [42, 47, 43]</span>

<span class="sd">    Then the orientation of the cell is computed as:</span>

<span class="sd">    C.index(M[0]) = 1; C.remove(M[0])</span>
<span class="sd">    C.index(M[1]) = 1; C.remove(M[1])</span>
<span class="sd">    C.index(M[2]) = 0; C.remove(M[2])</span>

<span class="sd">    o = (1 * 2!) + (1 * 1!) + (0 * 0!) = 3</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Simplex.is_simplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Simplex.is_simplex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_simplex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Simplex.symmetry_group_size">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Simplex.symmetry_group_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry_group_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Simplex.cell_orientation_reflection_map">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Simplex.cell_orientation_reflection_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_orientation_reflection_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the map indicating whether each possible cell orientation causes reflection (``1``) or not (``0``).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">make_cell_orientation_reflection_map_simplex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">())</span></div>


<div class="viewcode-block" id="Simplex.get_facet_element">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Simplex.get_facet_element">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_facet_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_subelement</span><span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>
</div>



<span class="c1"># Backwards compatible name</span>
<span class="n">ReferenceElement</span> <span class="o">=</span> <span class="n">Simplex</span>


<div class="viewcode-block" id="UFCSimplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCSimplex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UFCSimplex</span><span class="p">(</span><span class="n">Simplex</span><span class="p">):</span>

<div class="viewcode-block" id="UFCSimplex.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCSimplex.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: subentity dimension (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DefaultSimplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.DefaultSimplex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DefaultSimplex</span><span class="p">(</span><span class="n">Simplex</span><span class="p">):</span>

<div class="viewcode-block" id="DefaultSimplex.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.DefaultSimplex.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: subentity dimension (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">default_simplex</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SymmetricSimplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SymmetricSimplex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SymmetricSimplex</span><span class="p">(</span><span class="n">Simplex</span><span class="p">):</span>

<div class="viewcode-block" id="SymmetricSimplex.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.SymmetricSimplex.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: subentity dimension (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">symmetric_simplex</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Point">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Point">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="p">(</span><span class="n">Simplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference point.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((),)</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)}}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">POINT</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

<div class="viewcode-block" id="Point.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.Point.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: subentity dimension (integer). Must be zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="DefaultLine">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.DefaultLine">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DefaultLine</span><span class="p">(</span><span class="n">DefaultSimplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference line with vertices (-1.0,) and (1.0,).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)},</span>
                    <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">LINE</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span></div>



<div class="viewcode-block" id="UFCInterval">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCInterval">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UFCInterval</span><span class="p">(</span><span class="n">UFCSimplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference interval with vertices (0.0,) and (1.0,).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.0</span><span class="p">,),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)},</span>
                    <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">LINE</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span></div>



<div class="viewcode-block" id="DefaultTriangle">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.DefaultTriangle">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DefaultTriangle</span><span class="p">(</span><span class="n">DefaultSimplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference triangle with vertices (-1.0,-1.0),</span>
<span class="sd">    (1.0,-1.0), and (-1.0,1.0).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)},</span>
                    <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">faces</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TRIANGLE</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span></div>



<div class="viewcode-block" id="UFCTriangle">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCTriangle">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UFCTriangle</span><span class="p">(</span><span class="n">UFCSimplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference triangle with vertices (0.0,0.0),</span>
<span class="sd">    (1.0,0.0), and (0.0,1.0).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)},</span>
                    <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">faces</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TRIANGLE</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

<div class="viewcode-block" id="UFCTriangle.compute_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCTriangle.compute_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="s2">&quot;UFC consistent normal&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_tangents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="IntrepidTriangle">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.IntrepidTriangle">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IntrepidTriangle</span><span class="p">(</span><span class="n">Simplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the Intrepid triangle with vertices (0,0),(1,0),(0,1)&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)},</span>
                    <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">faces</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TRIANGLE</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

<div class="viewcode-block" id="IntrepidTriangle.get_facet_element">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.IntrepidTriangle.get_facet_element">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_facet_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># I think the UFC interval is equivalent to what the</span>
        <span class="c1"># IntrepidInterval would be.</span>
        <span class="k">return</span> <span class="n">UFCInterval</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="DefaultTetrahedron">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.DefaultTetrahedron">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DefaultTetrahedron</span><span class="p">(</span><span class="n">DefaultSimplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference tetrahedron with vertices (-1,-1,-1),</span>
<span class="sd">    (1,-1,-1),(-1,1,-1), and (-1,-1,1).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span>
                 <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">5</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">tets</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">vs</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">tets</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TETRAHEDRON</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span></div>



<div class="viewcode-block" id="IntrepidTetrahedron">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.IntrepidTetrahedron">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IntrepidTetrahedron</span><span class="p">(</span><span class="n">Simplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference tetrahedron with vertices (0,0,0),</span>
<span class="sd">    (1,0,0),(0,1,0), and (0,0,1) used in the Intrepid project.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">5</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">tets</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">vs</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">tets</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TETRAHEDRON</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

<div class="viewcode-block" id="IntrepidTetrahedron.get_facet_element">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.IntrepidTetrahedron.get_facet_element">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_facet_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">IntrepidTriangle</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="UFCTetrahedron">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCTetrahedron">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UFCTetrahedron</span><span class="p">(</span><span class="n">UFCSimplex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference tetrahedron with vertices (0,0,0),</span>
<span class="sd">    (1,0,0),(0,1,0), and (0,0,1).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">),</span>
              <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                 <span class="mi">5</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">tets</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">vs</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">faces</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="n">tets</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TETRAHEDRON</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

<div class="viewcode-block" id="UFCTetrahedron.compute_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCTetrahedron.compute_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="s2">&quot;UFC consistent normals.&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_tangents</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="TensorProductCell">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TensorProductCell</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A cell that is the product of FIAT cells.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">cells</span><span class="p">):</span>
        <span class="c1"># Vertices</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
                                                 <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]))</span>

        <span class="c1"># Topology</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">())</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">)</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                             <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">]):</span>
            <span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">topds</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()[</span><span class="n">d</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">cell</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">dim</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">tuple_ei</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">topd</span><span class="p">)</span><span class="k">for</span> <span class="n">topd</span> <span class="ow">in</span> <span class="n">topds</span><span class="p">]):</span>
                <span class="n">tuple_vs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">topd</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>
                                          <span class="k">for</span> <span class="n">topd</span><span class="p">,</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">topds</span><span class="p">,</span> <span class="n">tuple_ei</span><span class="p">)]))</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tuple_vs</span><span class="p">),</span> <span class="n">shape</span><span class="p">))</span>
                <span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">tuple_ei</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs</span>
            <span class="c1"># flatten entity numbers</span>
            <span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
                                           <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology</span><span class="p">[</span><span class="n">dim</span><span class="p">])))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">TENSORPRODUCT</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_split_slices</span><span class="p">(</span><span class="n">lengths</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        <span class="n">delimiter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">delimiter</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">delimiter</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">delimiter</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delimiter</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

<div class="viewcode-block" id="TensorProductCell.get_dimension">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.get_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the subelement dimension of the cell, a tuple of</span>
<span class="sd">        dimensions for each cell in the product.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span></div>


<div class="viewcode-block" id="TensorProductCell.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: dimension in each &quot;direction&quot; (tuple)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TensorProductCell</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">construct_subelement</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)])</span></div>


<div class="viewcode-block" id="TensorProductCell.construct_subcomplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.construct_subcomplex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subcomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference subcomplex of the parent cell subentity</span>
<span class="sd">        specified by subcomplex dimension.</span>

<span class="sd">        :arg dimension: dimension in each &quot;direction&quot; (tuple)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TensorProductCell</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">construct_subcomplex</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)])</span></div>


<div class="viewcode-block" id="TensorProductCell.get_entity_transform">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.get_entity_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_entity_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a mapping of point coordinates from the</span>
<span class="sd">        `entity_i`-th subentity of dimension `dim` to the cell.</span>

<span class="sd">        :arg dim: subelement dimension (tuple)</span>
<span class="sd">        :arg entity_i: entity number (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># unravel entity_i</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()[</span><span class="n">d</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">entity_i</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c1"># entity transform on each subcell</span>
        <span class="n">sct</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">get_entity_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)]</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="n">TensorProductCell</span><span class="o">.</span><span class="n">_split_slices</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">s</span><span class="p">])</span>
                                     <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sct</span><span class="p">,</span> <span class="n">slices</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transform</span></div>


<div class="viewcode-block" id="TensorProductCell.volume">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.volume">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the volume in the appropriate dimensional measure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span></div>


<div class="viewcode-block" id="TensorProductCell.compute_reference_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.compute_reference_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_reference_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_dim</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the unit normal in infinity norm to facet_i of</span>
<span class="sd">        subelement dimension facet_dim.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">facet_dim</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">())</span>
        <span class="n">indicator</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">())</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">facet_dim</span><span class="p">)</span>
        <span class="p">(</span><span class="n">cell_i</span><span class="p">,),</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">indicator</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cell_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">compute_reference_normal</span><span class="p">(</span><span class="n">facet_dim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">facet_i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="TensorProductCell.contains_point">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.contains_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if reference cell contains given point</span>
<span class="sd">        (with numerical tolerance as given by the L1 distance (aka &#39;manhatten&#39;,</span>
<span class="sd">        &#39;taxicab&#39; or rectilinear distance) to the cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : numpy.ndarray, list or symbolic expression</span>
<span class="sd">            The coordinates of the point.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            The tolerance for the check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if the point is inside the cell, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subcell_dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">subcell_dimensions</span><span class="p">)</span>
        <span class="n">point_slices</span> <span class="o">=</span> <span class="n">TensorProductCell</span><span class="o">.</span><span class="n">_split_slices</span><span class="p">(</span><span class="n">subcell_dimensions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">point_slices</span><span class="p">)),</span>
                      <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="TensorProductCell.distance_to_point_l1">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.distance_to_point_l1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_to_point_l1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the L1 distance (aka &#39;manhatten&#39;, &#39;taxicab&#39; or rectilinear</span>
<span class="sd">        distance) to a point with 0.0 if the point is inside the cell.</span>

<span class="sd">        For more information see the docstring for the UFCSimplex method.&quot;&quot;&quot;</span>
        <span class="n">subcell_dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">subcell_dimensions</span><span class="p">)</span>
        <span class="n">point_slices</span> <span class="o">=</span> <span class="n">TensorProductCell</span><span class="o">.</span><span class="n">_split_slices</span><span class="p">(</span><span class="n">subcell_dimensions</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">distance_to_point_l1</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">s</span><span class="p">],</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">point_slices</span><span class="p">))</span></div>


<div class="viewcode-block" id="TensorProductCell.symmetry_group_size">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.symmetry_group_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry_group_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">symmetry_group_size</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">))</span></div>


<div class="viewcode-block" id="TensorProductCell.cell_orientation_reflection_map">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.cell_orientation_reflection_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_orientation_reflection_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the map indicating whether each possible cell orientation causes reflection (``1``) or not (``0``).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">make_cell_orientation_reflection_map_tensorproduct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span></div>


<div class="viewcode-block" id="TensorProductCell.compare">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.compare">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;product&quot;</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">product</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">cells</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="TensorProductCell.extract_extrinsic_orientation">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.extract_extrinsic_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_extrinsic_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract extrinsic orientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : Orientation</span>
<span class="sd">            Total orientation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Orientation</span>
<span class="sd">            Extrinsic orientation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The difinition of orientations used here must be consistent with</span>
<span class="sd">        that used in make_entity_permutations_tensorproduct.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting an instance of Orientation : got </span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
        <span class="n">size_io</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of possible intrinsic orientations along each axis.</span>
        <span class="k">return</span> <span class="n">o</span> <span class="o">//</span> <span class="n">size_io</span><span class="o">**</span><span class="n">dim</span></div>


<div class="viewcode-block" id="TensorProductCell.extract_intrinsic_orientation">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.TensorProductCell.extract_intrinsic_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_intrinsic_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract intrinsic orientation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        o : Orientation</span>
<span class="sd">            Total orientation. ``//`` and ``%`` must be overloaded in type(o).</span>
<span class="sd">        axis : int</span>
<span class="sd">            Reference cell axis for which intrinsic orientation is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Orientation</span>
<span class="sd">            Intrinsic orientation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Must be consistent with make_entity_permutations_tensorproduct.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Orientation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expecting an instance of Orientation : got </span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Must give 0 &lt;= axis &lt; </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> : got </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">size_io</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of possible intrinsic orientations along each axis.</span>
        <span class="k">return</span> <span class="n">o</span> <span class="o">%</span> <span class="n">size_io</span><span class="o">**</span><span class="n">dim</span> <span class="o">//</span> <span class="n">size_io</span><span class="o">**</span><span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span><span class="p">)</span> <span class="o">%</span> <span class="n">size_io</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extrinsic_orientation_permutation_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A map from extrinsic orientations to corresponding axis permutation matrices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        result[eo] gives the physical axis-reference axis permutation matrix corresponding to</span>
<span class="sd">        eo (extrinsic orientation).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">factorial</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">make_entity_permutations_simplex</span><span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">factorial</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">put_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>



<div class="viewcode-block" id="UFCQuadrilateral">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UFCQuadrilateral</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is the reference quadrilateral with vertices</span>
<span class="sd">    (0.0, 0.0), (0.0, 1.0), (1.0, 0.0) and (1.0, 1.0).</span>

<span class="sd">    Orientation of a physical cell is computed systematically</span>
<span class="sd">    by comparing the canonical orderings of its facets and</span>
<span class="sd">    the facets in the FIAT reference cell.</span>

<span class="sd">    As an example, we compute the orientation of a</span>
<span class="sd">    quadrilateral cell:</span>

<span class="sd">       +---3---+           +--57---+</span>
<span class="sd">       |       |           |       |</span>
<span class="sd">       0       1          43       55</span>
<span class="sd">       |       |           |       |</span>
<span class="sd">       +---2---+           +--42---+</span>
<span class="sd">    FIAT canonical     Mapped example physical cell</span>

<span class="sd">    Suppose that the facets of the physical cell</span>
<span class="sd">    are canonically ordered as:</span>

<span class="sd">    C = [55, 42, 43, 57]</span>

<span class="sd">    FIAT index to Physical index map must be such that</span>
<span class="sd">    C[0] = 55 is mapped to a vertical facet; in this</span>
<span class="sd">    example it is:</span>

<span class="sd">    M = [43, 55, 42, 57]</span>

<span class="sd">    C and M are decomposed into &quot;vertical&quot; and &quot;horizontal&quot;</span>
<span class="sd">    parts, keeping the relative orders of numbers:</span>

<span class="sd">    C -&gt; C0 = [55, 43], C1 = [42, 57]</span>
<span class="sd">    M -&gt; M0 = [43, 55], M1 = [42, 57]</span>

<span class="sd">    Then the orientation of the cell is computed as the</span>
<span class="sd">    following:</span>

<span class="sd">    C0.index(M0[0]) = 1; C0.remove(M0[0])</span>
<span class="sd">    C0.index(M0[1]) = 0; C0.remove(M0[1])</span>
<span class="sd">    C1.index(M1[0]) = 0; C1.remove(M1[0])</span>
<span class="sd">    C1.index(M1[1]) = 0; C1.remove(M1[1])</span>

<span class="sd">    o = 2 * 1 + 0 = 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">=</span> <span class="n">TensorProductCell</span><span class="p">(</span><span class="n">UFCInterval</span><span class="p">(),</span> <span class="n">UFCInterval</span><span class="p">())</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="n">flatten_entities</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">QUADRILATERAL</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="n">product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unflattening_map</span> <span class="o">=</span> <span class="n">compute_unflattening_map</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

<div class="viewcode-block" id="UFCQuadrilateral.get_dimension">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.get_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the subelement dimension of the cell.  Same as the</span>
<span class="sd">        spatial dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: subentity dimension (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UFCInterval</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid dimension: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,))</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.get_entity_transform">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.get_entity_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_entity_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a mapping of point coordinates from the</span>
<span class="sd">        `entity_i`-th subentity of dimension `dim` to the cell.</span>

<span class="sd">        :arg dim: entity dimension (integer)</span>
<span class="sd">        :arg entity_i: entity number (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unflattening_map</span><span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">entity_i</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">get_entity_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.volume">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.volume">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the volume in the appropriate dimensional measure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.compute_reference_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.compute_reference_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_reference_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_dim</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the unit normal in infinity norm to facet_i.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">facet_dim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unflattening_map</span><span class="p">[(</span><span class="n">facet_dim</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">compute_reference_normal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.contains_point">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.contains_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if reference cell contains given point</span>
<span class="sd">        (with numerical tolerance as given by the L1 distance (aka &#39;manhatten&#39;,</span>
<span class="sd">        &#39;taxicab&#39; or rectilinear distance) to the cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : numpy.ndarray, list or symbolic expression</span>
<span class="sd">            The coordinates of the point.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            The tolerance for the check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if the point is inside the cell, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.distance_to_point_l1">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.distance_to_point_l1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_to_point_l1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the L1 distance (aka &#39;manhatten&#39;, &#39;taxicab&#39; or rectilinear</span>
<span class="sd">        distance) to a point with 0.0 if the point is inside the cell.</span>

<span class="sd">        For more information see the docstring for the UFCSimplex method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">distance_to_point_l1</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.symmetry_group_size">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.symmetry_group_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry_group_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span></div>


<div class="viewcode-block" id="UFCQuadrilateral.cell_orientation_reflection_map">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCQuadrilateral.cell_orientation_reflection_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_orientation_reflection_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the map indicating whether each possible cell orientation causes reflection (``1``) or not (``0``).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">cell_orientation_reflection_map</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&gt;</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&lt;</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&gt;=</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&lt;=</span> <span class="n">other</span></div>



<div class="viewcode-block" id="UFCHexahedron">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UFCHexahedron</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the reference hexahedron with vertices</span>
<span class="sd">    (0.0, 0.0, 0.0), (0.0, 0.0, 1.0), (0.0, 1.0, 0.0), (0.0, 1.0, 1.0),</span>
<span class="sd">    (1.0, 0.0, 0.0), (1.0, 0.0, 1.0), (1.0, 1.0, 0.0) and (1.0, 1.0, 1.0).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">=</span> <span class="n">TensorProductCell</span><span class="p">(</span><span class="n">UFCInterval</span><span class="p">(),</span> <span class="n">UFCInterval</span><span class="p">(),</span> <span class="n">UFCInterval</span><span class="p">())</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_topology</span><span class="p">()</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>
        <span class="n">topology</span> <span class="o">=</span> <span class="n">flatten_entities</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">HEXAHEDRON</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="n">product</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unflattening_map</span> <span class="o">=</span> <span class="n">compute_unflattening_map</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

<div class="viewcode-block" id="UFCHexahedron.get_dimension">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.get_dimension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the subelement dimension of the cell.  Same as the</span>
<span class="sd">        spatial dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spatial_dimension</span><span class="p">()</span></div>


<div class="viewcode-block" id="UFCHexahedron.construct_subelement">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.construct_subelement">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_subelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructs the reference element of a cell subentity</span>
<span class="sd">        specified by subelement dimension.</span>

<span class="sd">        :arg dimension: subentity dimension (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UFCQuadrilateral</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UFCInterval</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid dimension: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,))</span></div>


<div class="viewcode-block" id="UFCHexahedron.get_entity_transform">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.get_entity_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_entity_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entity_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a mapping of point coordinates from the</span>
<span class="sd">        `entity_i`-th subentity of dimension `dim` to the cell.</span>

<span class="sd">        :arg dim: entity dimension (integer)</span>
<span class="sd">        :arg entity_i: entity number (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unflattening_map</span><span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">entity_i</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">get_entity_transform</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCHexahedron.volume">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.volume">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the volume in the appropriate dimensional measure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span></div>


<div class="viewcode-block" id="UFCHexahedron.compute_reference_normal">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.compute_reference_normal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_reference_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet_dim</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the unit normal in infinity norm to facet_i.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">facet_dim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unflattening_map</span><span class="p">[(</span><span class="n">facet_dim</span><span class="p">,</span> <span class="n">facet_i</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">compute_reference_normal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCHexahedron.contains_point">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.contains_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">contains_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if reference cell contains given point</span>
<span class="sd">        (with numerical tolerance as given by the L1 distance (aka &#39;manhatten&#39;,</span>
<span class="sd">        &#39;taxicab&#39; or rectilinear distance) to the cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : numpy.ndarray, list or symbolic expression</span>
<span class="sd">            The coordinates of the point.</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            The tolerance for the check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if the point is inside the cell, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCHexahedron.distance_to_point_l1">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.distance_to_point_l1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_to_point_l1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the L1 distance (aka &#39;manhatten&#39;, &#39;taxicab&#39; or rectilinear</span>
<span class="sd">        distance) to a point with 0.0 if the point is inside the cell.</span>

<span class="sd">        For more information see the docstring for the UFCSimplex method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">distance_to_point_l1</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="n">rescale</span><span class="p">)</span></div>


<div class="viewcode-block" id="UFCHexahedron.symmetry_group_size">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.symmetry_group_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetry_group_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">48</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span></div>


<div class="viewcode-block" id="UFCHexahedron.cell_orientation_reflection_map">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.UFCHexahedron.cell_orientation_reflection_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell_orientation_reflection_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the map indicating whether each possible cell orientation causes reflection (``1``) or not (``0``).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">cell_orientation_reflection_map</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&gt;</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&lt;</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&gt;=</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">product</span> <span class="o">&lt;=</span> <span class="n">other</span></div>



<div class="viewcode-block" id="make_affine_mapping">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.make_affine_mapping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_affine_mapping</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constructs (A,b) such that x --&gt; A * x + b is the affine</span>
<span class="sd">    mapping from the simplex defined by xs to the simplex defined by ys.&quot;&quot;&quot;</span>

    <span class="n">dim_x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dim_y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># find A in R^{dim_y,dim_x}, b in R^{dim_y} such that</span>
    <span class="c1"># A xs[i] + b = ys[i] for all i</span>

    <span class="n">mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_x</span> <span class="o">*</span> <span class="n">dim_y</span> <span class="o">+</span> <span class="n">dim_y</span><span class="p">,</span> <span class="n">dim_x</span> <span class="o">*</span> <span class="n">dim_y</span> <span class="o">+</span> <span class="n">dim_y</span><span class="p">),</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim_x</span> <span class="o">*</span> <span class="n">dim_y</span> <span class="o">+</span> <span class="n">dim_y</span><span class="p">,),</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>

    <span class="c1"># loop over points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)):</span>
        <span class="c1"># loop over components of each A * point + b</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_y</span><span class="p">):</span>
            <span class="n">row_cur</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dim_y</span> <span class="o">+</span> <span class="n">j</span>
            <span class="n">col_start</span> <span class="o">=</span> <span class="n">dim_x</span> <span class="o">*</span> <span class="n">j</span>
            <span class="n">col_finish</span> <span class="o">=</span> <span class="n">col_start</span> <span class="o">+</span> <span class="n">dim_x</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">row_cur</span><span class="p">,</span> <span class="n">col_start</span><span class="p">:</span><span class="n">col_finish</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">rhs</span><span class="p">[</span><span class="n">row_cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="c1"># need to get terms related to b</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">row_cur</span><span class="p">,</span> <span class="n">dim_y</span> <span class="o">*</span> <span class="n">dim_x</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sol</span><span class="p">[:</span><span class="n">dim_x</span> <span class="o">*</span> <span class="n">dim_y</span><span class="p">],</span> <span class="p">(</span><span class="n">dim_y</span><span class="p">,</span> <span class="n">dim_x</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">dim_x</span> <span class="o">*</span> <span class="n">dim_y</span><span class="p">:]</span>

    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="default_simplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.default_simplex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">default_simplex</span><span class="p">(</span><span class="n">spatial_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory function that maps spatial dimension to an instance of</span>
<span class="sd">    the default reference simplex of that dimension.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Point</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DefaultLine</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DefaultTriangle</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DefaultTetrahedron</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t create default simplex of dimension </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spatial_dim</span><span class="p">))</span></div>



<div class="viewcode-block" id="ufc_simplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.ufc_simplex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ufc_simplex</span><span class="p">(</span><span class="n">spatial_dim</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Factory function that maps spatial dimension to an instance of</span>
<span class="sd">    the UFC reference simplex of that dimension.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Point</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UFCInterval</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UFCTriangle</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">spatial_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UFCTetrahedron</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t create UFC simplex of dimension </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spatial_dim</span><span class="p">))</span></div>



<div class="viewcode-block" id="symmetric_simplex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.symmetric_simplex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">symmetric_simplex</span><span class="p">(</span><span class="n">spatial_dim</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)]])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">spatial_dim</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">:</span><span class="n">spatial_dim</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">spatial_dim</span><span class="p">))</span>
    <span class="n">Ref1</span> <span class="o">=</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="n">spatial_dim</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ref1</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">(),</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SymmetricSimplex</span><span class="p">(</span><span class="n">Ref1</span><span class="o">.</span><span class="n">get_shape</span><span class="p">(),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">Ref1</span><span class="o">.</span><span class="n">get_topology</span><span class="p">())</span></div>



<div class="viewcode-block" id="ufc_cell">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.ufc_cell">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ufc_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handle incoming calls from FFC.&quot;&quot;&quot;</span>

    <span class="c1"># celltype could be a string or a cell.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">celltype</span> <span class="o">=</span> <span class="n">cell</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">celltype</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">cellname</span><span class="p">()</span>

    <span class="k">if</span> <span class="s2">&quot; * &quot;</span> <span class="ow">in</span> <span class="n">celltype</span><span class="p">:</span>
        <span class="c1"># Tensor product cell</span>
        <span class="k">return</span> <span class="n">TensorProductCell</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">ufc_cell</span><span class="p">,</span> <span class="n">celltype</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; * &quot;</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">celltype</span> <span class="o">==</span> <span class="s2">&quot;quadrilateral&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UFCQuadrilateral</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">celltype</span> <span class="o">==</span> <span class="s2">&quot;hexahedron&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UFCHexahedron</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">celltype</span> <span class="o">==</span> <span class="s2">&quot;vertex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">celltype</span> <span class="o">==</span> <span class="s2">&quot;interval&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">celltype</span> <span class="o">==</span> <span class="s2">&quot;triangle&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">celltype</span> <span class="o">==</span> <span class="s2">&quot;tetrahedron&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to create UFC cell of type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">celltype</span><span class="p">))</span></div>



<div class="viewcode-block" id="volume">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.volume">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="n">verts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constructs the volume of the simplex spanned by verts&quot;&quot;&quot;</span>

    <span class="c1"># use fact that volume of UFC reference element is 1/n!</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">ufcel</span> <span class="o">=</span> <span class="n">ufc_simplex</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>
    <span class="n">ufcverts</span> <span class="o">=</span> <span class="n">ufcel</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>

    <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">make_affine_mapping</span><span class="p">(</span><span class="n">ufcverts</span><span class="p">,</span> <span class="n">verts</span><span class="p">)</span>

    <span class="c1"># can&#39;t just take determinant since, e.g. the face of</span>
    <span class="c1"># a tet being mapped to a 2d triangle doesn&#39;t have a</span>
    <span class="c1"># square matrix</span>

    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span><span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># this is the determinant of the &quot;square part&quot; of the matrix</span>
    <span class="c1"># (ie the part that maps the restriction of the higher-dimensional</span>
    <span class="c1"># stuff to UFC element</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">si</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-10</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">p</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span></div>



<div class="viewcode-block" id="tuple_sum">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.tuple_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tuple_sum</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the sum of elements in a tuple, it is needed to handle nested tuples in TensorProductCell.</span>
<span class="sd">    Example: tuple_sum(((1, 0), 1)) returns 2</span>
<span class="sd">    If input argument is not the tuple, returns input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">tuple_sum</span><span class="p">,</span> <span class="n">tree</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tree</span></div>



<div class="viewcode-block" id="is_hypercube">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.is_hypercube">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_hypercube</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="p">(</span><span class="n">DefaultLine</span><span class="p">,</span> <span class="n">UFCInterval</span><span class="p">,</span> <span class="n">UFCQuadrilateral</span><span class="p">,</span> <span class="n">UFCHexahedron</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">TensorProductCell</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">is_hypercube</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">cells</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="flatten_reference_cube">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.flatten_reference_cube">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten_reference_cube</span><span class="p">(</span><span class="n">ref_el</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function flattens a Tensor Product hypercube to the corresponding UFC hypercube&quot;&quot;&quot;</span>
    <span class="n">flattened_cube</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">UFCQuadrilateral</span><span class="p">(),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">UFCHexahedron</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref_el</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Just return point/interval cell arguments</span>
        <span class="k">return</span> <span class="n">ref_el</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle cases where cell is a quad/cube constructed from a tensor product or</span>
        <span class="c1"># an already flattened element</span>
        <span class="k">if</span> <span class="n">is_hypercube</span><span class="p">(</span><span class="n">ref_el</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">flattened_cube</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref_el</span><span class="o">.</span><span class="n">get_dimension</span><span class="p">())]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid cell type&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="flatten_entities">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.flatten_entities">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten_entities</span><span class="p">(</span><span class="n">topology_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function flattens topology dict of TensorProductCell and entity_dofs dict of TensorProductElement&quot;&quot;&quot;</span>

    <span class="n">flattened_entities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">flat_dim</span> <span class="o">=</span> <span class="n">tuple_sum</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">flattened_entities</span><span class="p">[</span><span class="n">flat_dim</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology_dict</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">entities</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entities</span> <span class="ow">in</span> <span class="n">flattened_entities</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>



<div class="viewcode-block" id="flatten_permutations">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.flatten_permutations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten_permutations</span><span class="p">(</span><span class="n">perm_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function flattens permutation dict of TensorProductElement&quot;&quot;&quot;</span>

    <span class="n">flattened_permutations</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">perm_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">flat_dim</span> <span class="o">=</span> <span class="n">tuple_sum</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">flattened_permutations</span><span class="p">[</span><span class="n">flat_dim</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[{</span><span class="n">o</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">o_tuple</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">o_tuple</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="p">))}</span>
                                             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">perm_dict</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">perms</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">perms</span> <span class="ow">in</span> <span class="n">flattened_permutations</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>



<div class="viewcode-block" id="compute_unflattening_map">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.compute_unflattening_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_unflattening_map</span><span class="p">(</span><span class="n">topology_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function returns unflattening map for the given tensor product topology dict.&quot;&quot;&quot;</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="n">unflattening_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">entities</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">topology_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">flat_dim</span> <span class="o">=</span> <span class="n">tuple_sum</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
            <span class="n">flat_entity</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">flat_dim</span><span class="p">])</span>
            <span class="n">unflattening_map</span><span class="p">[(</span><span class="n">flat_dim</span><span class="p">,</span> <span class="n">flat_entity</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unflattening_map</span></div>



<div class="viewcode-block" id="max_complex">
<a class="viewcode-back" href="../../FIAT.html#FIAT.reference_element.max_complex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">max_complex</span><span class="p">(</span><span class="n">complexes</span><span class="p">):</span>
    <span class="n">max_cell</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">complexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">max_cell</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">complexes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">max_cell</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find the maximal complex&quot;</span><span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">FInite element Automatic Tabulator (FIAT) 2024.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">FIAT.reference_element</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, FEniCS Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>